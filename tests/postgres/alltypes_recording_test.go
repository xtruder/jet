// Code generated by testparrot. DO NOT EDIT.

package postgres

import (
	qrm "github.com/go-jet/jet/v2/qrm"
	common "github.com/go-jet/jet/v2/tests/common"
	model "github.com/go-jet/jet/v2/tests/postgres/gen/test_sample/model"
	uuid "github.com/google/uuid"
	pq "github.com/lib/pq"
	gotestparrot "github.com/xtruder/go-testparrot"
	"time"
)

func init() {
	gotestparrot.R.Load("TestAllTypesFromSubQuery", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT "allTypesSubQuery"."all_types.small_int_ptr" AS "all_types.small_int_ptr",
     "allTypesSubQuery"."all_types.small_int" AS "all_types.small_int",
     "allTypesSubQuery"."all_types.integer_ptr" AS "all_types.integer_ptr",
     "allTypesSubQuery"."all_types.integer" AS "all_types.integer",
     "allTypesSubQuery"."all_types.big_int_ptr" AS "all_types.big_int_ptr",
     "allTypesSubQuery"."all_types.big_int" AS "all_types.big_int",
     "allTypesSubQuery"."all_types.decimal_ptr" AS "all_types.decimal_ptr",
     "allTypesSubQuery"."all_types.decimal" AS "all_types.decimal",
     "allTypesSubQuery"."all_types.numeric_ptr" AS "all_types.numeric_ptr",
     "allTypesSubQuery"."all_types.numeric" AS "all_types.numeric",
     "allTypesSubQuery"."all_types.real_ptr" AS "all_types.real_ptr",
     "allTypesSubQuery"."all_types.real" AS "all_types.real",
     "allTypesSubQuery"."all_types.double_precision_ptr" AS "all_types.double_precision_ptr",
     "allTypesSubQuery"."all_types.double_precision" AS "all_types.double_precision",
     "allTypesSubQuery"."all_types.smallserial" AS "all_types.smallserial",
     "allTypesSubQuery"."all_types.serial" AS "all_types.serial",
     "allTypesSubQuery"."all_types.bigserial" AS "all_types.bigserial",
     "allTypesSubQuery"."all_types.var_char_ptr" AS "all_types.var_char_ptr",
     "allTypesSubQuery"."all_types.var_char" AS "all_types.var_char",
     "allTypesSubQuery"."all_types.char_ptr" AS "all_types.char_ptr",
     "allTypesSubQuery"."all_types.char" AS "all_types.char",
     "allTypesSubQuery"."all_types.text_ptr" AS "all_types.text_ptr",
     "allTypesSubQuery"."all_types.text" AS "all_types.text",
     "allTypesSubQuery"."all_types.bytea_ptr" AS "all_types.bytea_ptr",
     "allTypesSubQuery"."all_types.bytea" AS "all_types.bytea",
     "allTypesSubQuery"."all_types.timestampz_ptr" AS "all_types.timestampz_ptr",
     "allTypesSubQuery"."all_types.timestampz" AS "all_types.timestampz",
     "allTypesSubQuery"."all_types.timestamp_ptr" AS "all_types.timestamp_ptr",
     "allTypesSubQuery"."all_types.timestamp" AS "all_types.timestamp",
     "allTypesSubQuery"."all_types.date_ptr" AS "all_types.date_ptr",
     "allTypesSubQuery"."all_types.date" AS "all_types.date",
     "allTypesSubQuery"."all_types.timez_ptr" AS "all_types.timez_ptr",
     "allTypesSubQuery"."all_types.timez" AS "all_types.timez",
     "allTypesSubQuery"."all_types.time_ptr" AS "all_types.time_ptr",
     "allTypesSubQuery"."all_types.time" AS "all_types.time",
     "allTypesSubQuery"."all_types.interval_ptr" AS "all_types.interval_ptr",
     "allTypesSubQuery"."all_types.interval" AS "all_types.interval",
     "allTypesSubQuery"."all_types.boolean_ptr" AS "all_types.boolean_ptr",
     "allTypesSubQuery"."all_types.boolean" AS "all_types.boolean",
     "allTypesSubQuery"."all_types.point_ptr" AS "all_types.point_ptr",
     "allTypesSubQuery"."all_types.bit_ptr" AS "all_types.bit_ptr",
     "allTypesSubQuery"."all_types.bit" AS "all_types.bit",
     "allTypesSubQuery"."all_types.bit_varying_ptr" AS "all_types.bit_varying_ptr",
     "allTypesSubQuery"."all_types.bit_varying" AS "all_types.bit_varying",
     "allTypesSubQuery"."all_types.tsvector_ptr" AS "all_types.tsvector_ptr",
     "allTypesSubQuery"."all_types.tsvector" AS "all_types.tsvector",
     "allTypesSubQuery"."all_types.uuid_ptr" AS "all_types.uuid_ptr",
     "allTypesSubQuery"."all_types.uuid" AS "all_types.uuid",
     "allTypesSubQuery"."all_types.xml_ptr" AS "all_types.xml_ptr",
     "allTypesSubQuery"."all_types.xml" AS "all_types.xml",
     "allTypesSubQuery"."all_types.json_ptr" AS "all_types.json_ptr",
     "allTypesSubQuery"."all_types.json" AS "all_types.json",
     "allTypesSubQuery"."all_types.jsonb_ptr" AS "all_types.jsonb_ptr",
     "allTypesSubQuery"."all_types.jsonb" AS "all_types.jsonb",
     "allTypesSubQuery"."all_types.integer_array_ptr" AS "all_types.integer_array_ptr",
     "allTypesSubQuery"."all_types.integer_array" AS "all_types.integer_array",
     "allTypesSubQuery"."all_types.text_array_ptr" AS "all_types.text_array_ptr",
     "allTypesSubQuery"."all_types.text_array" AS "all_types.text_array",
     "allTypesSubQuery"."all_types.jsonb_array" AS "all_types.jsonb_array",
     "allTypesSubQuery"."all_types.text_multi_dim_array_ptr" AS "all_types.text_multi_dim_array_ptr",
     "allTypesSubQuery"."all_types.text_multi_dim_array" AS "all_types.text_multi_dim_array"
FROM (
          SELECT all_types.small_int_ptr AS "all_types.small_int_ptr",
               all_types.small_int AS "all_types.small_int",
               all_types.integer_ptr AS "all_types.integer_ptr",
               all_types.integer AS "all_types.integer",
               all_types.big_int_ptr AS "all_types.big_int_ptr",
               all_types.big_int AS "all_types.big_int",
               all_types.decimal_ptr AS "all_types.decimal_ptr",
               all_types.decimal AS "all_types.decimal",
               all_types.numeric_ptr AS "all_types.numeric_ptr",
               all_types.numeric AS "all_types.numeric",
               all_types.real_ptr AS "all_types.real_ptr",
               all_types.real AS "all_types.real",
               all_types.double_precision_ptr AS "all_types.double_precision_ptr",
               all_types.double_precision AS "all_types.double_precision",
               all_types.smallserial AS "all_types.smallserial",
               all_types.serial AS "all_types.serial",
               all_types.bigserial AS "all_types.bigserial",
               all_types.var_char_ptr AS "all_types.var_char_ptr",
               all_types.var_char AS "all_types.var_char",
               all_types.char_ptr AS "all_types.char_ptr",
               all_types.char AS "all_types.char",
               all_types.text_ptr AS "all_types.text_ptr",
               all_types.text AS "all_types.text",
               all_types.bytea_ptr AS "all_types.bytea_ptr",
               all_types.bytea AS "all_types.bytea",
               all_types.timestampz_ptr AS "all_types.timestampz_ptr",
               all_types.timestampz AS "all_types.timestampz",
               all_types.timestamp_ptr AS "all_types.timestamp_ptr",
               all_types.timestamp AS "all_types.timestamp",
               all_types.date_ptr AS "all_types.date_ptr",
               all_types.date AS "all_types.date",
               all_types.timez_ptr AS "all_types.timez_ptr",
               all_types.timez AS "all_types.timez",
               all_types.time_ptr AS "all_types.time_ptr",
               all_types.time AS "all_types.time",
               all_types.interval_ptr AS "all_types.interval_ptr",
               all_types.interval AS "all_types.interval",
               all_types.boolean_ptr AS "all_types.boolean_ptr",
               all_types.boolean AS "all_types.boolean",
               all_types.point_ptr AS "all_types.point_ptr",
               all_types.bit_ptr AS "all_types.bit_ptr",
               all_types.bit AS "all_types.bit",
               all_types.bit_varying_ptr AS "all_types.bit_varying_ptr",
               all_types.bit_varying AS "all_types.bit_varying",
               all_types.tsvector_ptr AS "all_types.tsvector_ptr",
               all_types.tsvector AS "all_types.tsvector",
               all_types.uuid_ptr AS "all_types.uuid_ptr",
               all_types.uuid AS "all_types.uuid",
               all_types.xml_ptr AS "all_types.xml_ptr",
               all_types.xml AS "all_types.xml",
               all_types.json_ptr AS "all_types.json_ptr",
               all_types.json AS "all_types.json",
               all_types.jsonb_ptr AS "all_types.jsonb_ptr",
               all_types.jsonb AS "all_types.jsonb",
               all_types.integer_array_ptr AS "all_types.integer_array_ptr",
               all_types.integer_array AS "all_types.integer_array",
               all_types.text_array_ptr AS "all_types.text_array_ptr",
               all_types.text_array AS "all_types.text_array",
               all_types.jsonb_array AS "all_types.jsonb_array",
               all_types.text_multi_dim_array_ptr AS "all_types.text_multi_dim_array_ptr",
               all_types.text_multi_dim_array AS "all_types.text_multi_dim_array"
          FROM test_sample.all_types
     ) AS "allTypesSubQuery"
LIMIT 2;
`,
	}})
	gotestparrot.R.Load("TestAllTypesSelect", []gotestparrot.Recording{{
		Key: 0,
		Value: []model.AllTypes{{
			BigInt:               int64(5000),
			BigIntPtr:            gotestparrot.Ptr(int64(50000)).(*int64),
			Bigserial:            int64(1),
			Bit:                  "101",
			BitPtr:               gotestparrot.Ptr("101").(*string),
			BitVarying:           "101111",
			BitVaryingPtr:        gotestparrot.Ptr("101111").(*string),
			BooleanPtr:           gotestparrot.Ptr(true).(*bool),
			Bytea:                []uint8{uint8(0x62), uint8(0x79), uint8(0x74), uint8(0x65), uint8(0x61)},
			ByteaPtr:             gotestparrot.Ptr([]uint8{uint8(0x62), uint8(0x79), uint8(0x74), uint8(0x65), uint8(0x61)}).(*[]uint8),
			Char:                 "JOHN                                                                            ",
			CharPtr:              gotestparrot.Ptr("JOHN                                                                            ").(*string),
			Date:                 gotestparrot.Decode("1999-01-08T00:00:00Z", time.Time{}).(time.Time),
			DatePtr:              gotestparrot.Decode("1999-01-08T00:00:00Z", &time.Time{}).(*time.Time),
			Decimal:              1.11,
			DecimalPtr:           gotestparrot.Ptr(1.11).(*float64),
			DoublePrecision:      1.111111122e+07,
			DoublePrecisionPtr:   gotestparrot.Ptr(1.111111122e+07).(*float64),
			Integer:              int32(300),
			IntegerArray:         "{1,2,3}",
			IntegerArrayPtr:      gotestparrot.Ptr("{1,2,3}").(*string),
			IntegerPtr:           gotestparrot.Ptr(int32(300)).(*int32),
			Interval:             "3 days 04:05:06",
			IntervalPtr:          gotestparrot.Ptr("3 days 04:05:06").(*string),
			JSON:                 gotestparrot.Decode("{\"a\": 1, \"b\": 3}", qrm.JSON{}).(qrm.JSON),
			JSONPtr:              gotestparrot.Decode("{\"a\": 1, \"b\": 3}", &qrm.JSON{}).(*qrm.JSON),
			Jsonb:                gotestparrot.Decode("{\"a\": 1, \"b\": 3}", qrm.JSON{}).(qrm.JSON),
			JsonbArray:           "{\"{\\\"a\\\": 1, \\\"b\\\": 2}\",\"{\\\"a\\\": 3, \\\"b\\\": 4}\"}",
			JsonbPtr:             gotestparrot.Decode("{\"a\": 1, \"b\": 3}", &qrm.JSON{}).(*qrm.JSON),
			Numeric:              2.22,
			NumericPtr:           gotestparrot.Ptr(2.22).(*float64),
			PointPtr:             gotestparrot.Ptr("(2,3)").(*string),
			Real:                 float32(5.55),
			RealPtr:              gotestparrot.Ptr(float32(5.55)).(*float32),
			Serial:               int32(1),
			SmallInt:             int16(14),
			SmallIntPtr:          gotestparrot.Ptr(int16(14)).(*int16),
			Smallserial:          int16(1),
			Text:                 "Some text",
			TextArray:            "{breakfast,consulting}",
			TextArrayPtr:         gotestparrot.Ptr("{breakfast,consulting}").(*string),
			TextMultiDimArray:    "{{meeting,lunch},{training,presentation}}",
			TextMultiDimArrayPtr: gotestparrot.Ptr("{{meeting,lunch},{training,presentation}}").(*string),
			TextPtr:              gotestparrot.Ptr("Some text").(*string),
			Time:                 gotestparrot.Decode("0000-01-01T04:05:06Z", time.Time{}).(time.Time),
			TimePtr:              gotestparrot.Decode("0000-01-01T04:05:06Z", &time.Time{}).(*time.Time),
			Timestamp:            gotestparrot.Decode("1999-01-08T04:05:06Z", time.Time{}).(time.Time),
			TimestampPtr:         gotestparrot.Decode("1999-01-08T04:05:06Z", &time.Time{}).(*time.Time),
			Timestampz:           gotestparrot.Decode("1999-01-08T12:05:06Z", time.Time{}).(time.Time),
			TimestampzPtr:        gotestparrot.Decode("1999-01-08T12:05:06Z", &time.Time{}).(*time.Time),
			Timez:                gotestparrot.Decode("0000-01-01T04:05:06-08:00", time.Time{}).(time.Time),
			TimezPtr:             gotestparrot.Decode("0000-01-01T04:05:06-08:00", &time.Time{}).(*time.Time),
			Tsvector:             "'supernova':1",
			TsvectorPtr:          gotestparrot.Ptr("'supernova':1").(*string),
			UUID:                 gotestparrot.Decode("a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11", uuid.UUID{}).(uuid.UUID),
			UUIDPtr:              gotestparrot.Decode("a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11", &uuid.UUID{}).(*uuid.UUID),
			VarChar:              "ABBA",
			VarCharPtr:           gotestparrot.Ptr("ABBA").(*string),
			XML:                  "<Sub>abc</Sub>",
			XMLPtr:               gotestparrot.Ptr("<Sub>abc</Sub>").(*string),
		}, {
			BigInt:            int64(5000),
			Bigserial:         int64(2),
			Bit:               "101",
			BitVarying:        "101111",
			Bytea:             []uint8{uint8(0x62), uint8(0x79), uint8(0x74), uint8(0x65), uint8(0x61)},
			Char:              "JOHN                                                                            ",
			Date:              gotestparrot.Decode("1999-01-08T00:00:00Z", time.Time{}).(time.Time),
			Decimal:           1.11,
			DoublePrecision:   1.111111122e+07,
			Integer:           int32(300),
			IntegerArray:      "{1,2,3}",
			Interval:          "3 days 04:05:06",
			JSON:              gotestparrot.Decode("{\"a\": 1, \"b\": 3}", qrm.JSON{}).(qrm.JSON),
			Jsonb:             gotestparrot.Decode("{\"a\": 1, \"b\": 3}", qrm.JSON{}).(qrm.JSON),
			JsonbArray:        "{\"{\\\"a\\\": 1, \\\"b\\\": 2}\",\"{\\\"a\\\": 3, \\\"b\\\": 4}\"}",
			Numeric:           2.22,
			Real:              float32(5.55),
			Serial:            int32(2),
			SmallInt:          int16(14),
			Smallserial:       int16(2),
			Text:              "Some text",
			TextArray:         "{breakfast,consulting}",
			TextMultiDimArray: "{{meeting,lunch},{training,presentation}}",
			Time:              gotestparrot.Decode("0000-01-01T04:05:06Z", time.Time{}).(time.Time),
			Timestamp:         gotestparrot.Decode("1999-01-08T04:05:06Z", time.Time{}).(time.Time),
			Timestampz:        gotestparrot.Decode("1999-01-08T12:05:06Z", time.Time{}).(time.Time),
			Timez:             gotestparrot.Decode("0000-01-01T04:05:06-08:00", time.Time{}).(time.Time),
			Tsvector:          "'supernova':1",
			UUID:              gotestparrot.Decode("a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11", uuid.UUID{}).(uuid.UUID),
			VarChar:           "ABBA",
			XML:               "<Sub>abc</Sub>",
		}},
	}})
	gotestparrot.R.Load("TestAllTypesViewSelect", []gotestparrot.Recording{{
		Key: 0,
		Value: []AllTypesView{{
			BigInt:               int64(5000),
			BigIntPtr:            gotestparrot.Ptr(int64(50000)).(*int64),
			Bigserial:            int64(1),
			Bit:                  "101",
			BitPtr:               gotestparrot.Ptr("101").(*string),
			BitVarying:           "101111",
			BitVaryingPtr:        gotestparrot.Ptr("101111").(*string),
			BooleanPtr:           gotestparrot.Ptr(true).(*bool),
			Bytea:                []uint8{uint8(0x62), uint8(0x79), uint8(0x74), uint8(0x65), uint8(0x61)},
			ByteaPtr:             gotestparrot.Ptr([]uint8{uint8(0x62), uint8(0x79), uint8(0x74), uint8(0x65), uint8(0x61)}).(*[]uint8),
			Char:                 "JOHN                                                                            ",
			CharPtr:              gotestparrot.Ptr("JOHN                                                                            ").(*string),
			Date:                 gotestparrot.Decode("1999-01-08T00:00:00Z", time.Time{}).(time.Time),
			DatePtr:              gotestparrot.Decode("1999-01-08T00:00:00Z", &time.Time{}).(*time.Time),
			Decimal:              1.11,
			DecimalPtr:           gotestparrot.Ptr(1.11).(*float64),
			DoublePrecision:      1.111111122e+07,
			DoublePrecisionPtr:   gotestparrot.Ptr(1.111111122e+07).(*float64),
			Integer:              int32(300),
			IntegerArray:         "{1,2,3}",
			IntegerArrayPtr:      gotestparrot.Ptr("{1,2,3}").(*string),
			IntegerPtr:           gotestparrot.Ptr(int32(300)).(*int32),
			Interval:             "3 days 04:05:06",
			IntervalPtr:          gotestparrot.Ptr("3 days 04:05:06").(*string),
			JSON:                 gotestparrot.Decode("{\"a\": 1, \"b\": 3}", qrm.JSON{}).(qrm.JSON),
			JSONPtr:              gotestparrot.Decode("{\"a\": 1, \"b\": 3}", &qrm.JSON{}).(*qrm.JSON),
			Jsonb:                gotestparrot.Decode("{\"a\": 1, \"b\": 3}", qrm.JSON{}).(qrm.JSON),
			JsonbArray:           "{\"{\\\"a\\\": 1, \\\"b\\\": 2}\",\"{\\\"a\\\": 3, \\\"b\\\": 4}\"}",
			JsonbPtr:             gotestparrot.Decode("{\"a\": 1, \"b\": 3}", &qrm.JSON{}).(*qrm.JSON),
			Numeric:              2.22,
			NumericPtr:           gotestparrot.Ptr(2.22).(*float64),
			PointPtr:             gotestparrot.Ptr("(2,3)").(*string),
			Real:                 float32(5.55),
			RealPtr:              gotestparrot.Ptr(float32(5.55)).(*float32),
			Serial:               int32(1),
			SmallInt:             int16(14),
			SmallIntPtr:          gotestparrot.Ptr(int16(14)).(*int16),
			Smallserial:          int16(1),
			Text:                 "Some text",
			TextArray:            "{breakfast,consulting}",
			TextArrayPtr:         gotestparrot.Ptr("{breakfast,consulting}").(*string),
			TextMultiDimArray:    "{{meeting,lunch},{training,presentation}}",
			TextMultiDimArrayPtr: gotestparrot.Ptr("{{meeting,lunch},{training,presentation}}").(*string),
			TextPtr:              gotestparrot.Ptr("Some text").(*string),
			Time:                 gotestparrot.Decode("0000-01-01T04:05:06Z", time.Time{}).(time.Time),
			TimePtr:              gotestparrot.Decode("0000-01-01T04:05:06Z", &time.Time{}).(*time.Time),
			Timestamp:            gotestparrot.Decode("1999-01-08T04:05:06Z", time.Time{}).(time.Time),
			TimestampPtr:         gotestparrot.Decode("1999-01-08T04:05:06Z", &time.Time{}).(*time.Time),
			Timestampz:           gotestparrot.Decode("1999-01-08T12:05:06Z", time.Time{}).(time.Time),
			TimestampzPtr:        gotestparrot.Decode("1999-01-08T12:05:06Z", &time.Time{}).(*time.Time),
			Timez:                gotestparrot.Decode("0000-01-01T04:05:06-08:00", time.Time{}).(time.Time),
			TimezPtr:             gotestparrot.Decode("0000-01-01T04:05:06-08:00", &time.Time{}).(*time.Time),
			Tsvector:             "'supernova':1",
			TsvectorPtr:          gotestparrot.Ptr("'supernova':1").(*string),
			UUID:                 gotestparrot.Decode("a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11", uuid.UUID{}).(uuid.UUID),
			UUIDPtr:              gotestparrot.Decode("a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11", &uuid.UUID{}).(*uuid.UUID),
			VarChar:              "ABBA",
			VarCharPtr:           gotestparrot.Ptr("ABBA").(*string),
			XML:                  "<Sub>abc</Sub>",
			XMLPtr:               gotestparrot.Ptr("<Sub>abc</Sub>").(*string),
		}, {
			BigInt:            int64(5000),
			Bigserial:         int64(2),
			Bit:               "101",
			BitVarying:        "101111",
			Bytea:             []uint8{uint8(0x62), uint8(0x79), uint8(0x74), uint8(0x65), uint8(0x61)},
			Char:              "JOHN                                                                            ",
			Date:              gotestparrot.Decode("1999-01-08T00:00:00Z", time.Time{}).(time.Time),
			Decimal:           1.11,
			DoublePrecision:   1.111111122e+07,
			Integer:           int32(300),
			IntegerArray:      "{1,2,3}",
			Interval:          "3 days 04:05:06",
			JSON:              gotestparrot.Decode("{\"a\": 1, \"b\": 3}", qrm.JSON{}).(qrm.JSON),
			Jsonb:             gotestparrot.Decode("{\"a\": 1, \"b\": 3}", qrm.JSON{}).(qrm.JSON),
			JsonbArray:        "{\"{\\\"a\\\": 1, \\\"b\\\": 2}\",\"{\\\"a\\\": 3, \\\"b\\\": 4}\"}",
			Numeric:           2.22,
			Real:              float32(5.55),
			Serial:            int32(2),
			SmallInt:          int16(14),
			Smallserial:       int16(2),
			Text:              "Some text",
			TextArray:         "{breakfast,consulting}",
			TextMultiDimArray: "{{meeting,lunch},{training,presentation}}",
			Time:              gotestparrot.Decode("0000-01-01T04:05:06Z", time.Time{}).(time.Time),
			Timestamp:         gotestparrot.Decode("1999-01-08T04:05:06Z", time.Time{}).(time.Time),
			Timestampz:        gotestparrot.Decode("1999-01-08T12:05:06Z", time.Time{}).(time.Time),
			Timez:             gotestparrot.Decode("0000-01-01T04:05:06-08:00", time.Time{}).(time.Time),
			Tsvector:          "'supernova':1",
			UUID:              gotestparrot.Decode("a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11", uuid.UUID{}).(uuid.UUID),
			VarChar:           "ABBA",
			XML:               "<Sub>abc</Sub>",
		}},
	}})
	gotestparrot.R.Load("TestBoolOperators", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT (all_types.boolean = all_types.boolean_ptr) AS "EQ1",
     (all_types.boolean = $1) AS "EQ2",
     (all_types.boolean != all_types.boolean_ptr) AS "NEq1",
     (all_types.boolean != $2) AS "NEq2",
     (all_types.boolean IS DISTINCT FROM all_types.boolean_ptr) AS "distinct1",
     (all_types.boolean IS DISTINCT FROM $3) AS "distinct2",
     (all_types.boolean IS NOT DISTINCT FROM all_types.boolean_ptr) AS "not_distinct_1",
     (all_types.boolean IS NOT DISTINCT FROM $4) AS "NOTDISTINCT2",
     all_types.boolean IS TRUE AS "ISTRUE",
     all_types.boolean IS NOT TRUE AS "isnottrue",
     all_types.boolean IS FALSE AS "is_False",
     all_types.boolean IS NOT FALSE AS "is not false",
     all_types.boolean IS UNKNOWN AS "is unknown",
     all_types.boolean IS NOT UNKNOWN AS "is_not_unknown",
     ((all_types.boolean AND all_types.boolean) = (all_types.boolean AND all_types.boolean)) AS "complex1",
     ((all_types.boolean OR all_types.boolean) = (all_types.boolean AND all_types.boolean)) AS "complex2"
FROM test_sample.all_types
LIMIT $5;
`,
	}, {
		Key:   1,
		Value: []interface{}{true, false, true, true, int64(2)},
	}, {
		Key: 2,
		Value: []boolOperatorsResult{{
			Complex1:     gotestparrot.Ptr(true).(*bool),
			Complex2:     gotestparrot.Ptr(true).(*bool),
			Distinct1:    gotestparrot.Ptr(true).(*bool),
			Distinct2:    gotestparrot.Ptr(true).(*bool),
			Eq1:          gotestparrot.Ptr(false).(*bool),
			Eq2:          gotestparrot.Ptr(false).(*bool),
			IsFalse:      gotestparrot.Ptr(true).(*bool),
			IsNotFalse:   gotestparrot.Ptr(false).(*bool),
			IsNotTrue:    gotestparrot.Ptr(true).(*bool),
			IsNotUnknown: gotestparrot.Ptr(true).(*bool),
			IsTrue:       gotestparrot.Ptr(false).(*bool),
			IsUnknown:    gotestparrot.Ptr(false).(*bool),
			NEq1:         gotestparrot.Ptr(true).(*bool),
			NEq2:         gotestparrot.Ptr(false).(*bool),
			NotDistinct1: gotestparrot.Ptr(false).(*bool),
			NotDistinct2: gotestparrot.Ptr(false).(*bool),
		}, {
			Complex1:     gotestparrot.Ptr(true).(*bool),
			Complex2:     gotestparrot.Ptr(true).(*bool),
			Distinct1:    gotestparrot.Ptr(true).(*bool),
			Distinct2:    gotestparrot.Ptr(true).(*bool),
			Eq2:          gotestparrot.Ptr(false).(*bool),
			IsFalse:      gotestparrot.Ptr(true).(*bool),
			IsNotFalse:   gotestparrot.Ptr(false).(*bool),
			IsNotTrue:    gotestparrot.Ptr(true).(*bool),
			IsNotUnknown: gotestparrot.Ptr(true).(*bool),
			IsTrue:       gotestparrot.Ptr(false).(*bool),
			IsUnknown:    gotestparrot.Ptr(false).(*bool),
			NEq2:         gotestparrot.Ptr(false).(*bool),
			NotDistinct1: gotestparrot.Ptr(false).(*bool),
			NotDistinct2: gotestparrot.Ptr(false).(*bool),
		}},
	}})
	gotestparrot.R.Load("TestExpressionCast", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT $1::char(12) AS "char12",
     $2::boolean,
     $3::smallint,
     $4::integer,
     $5::bigint,
     $6::numeric(30, 10),
     $7::numeric(30),
     $8::numeric,
     $9::real,
     $10::double precision,
     $11::text,
     $12::date,
     $13::time without time zone,
     $14::time with time zone,
     $15::timestamp without time zone,
     $16::timestamp with time zone,
     $17::interval,
     $18::json::text,
     TO_CHAR(all_types.timestamp, $19),
     TO_CHAR(all_types.integer, $20),
     TO_CHAR(all_types.double_precision, $21),
     TO_CHAR(all_types.numeric, $22),
     TO_DATE($23, $24),
     TO_NUMBER($25, $26),
     TO_TIMESTAMP($27, $28),
     COALESCE(all_types.integer_ptr, all_types.small_int_ptr, NULL, $29),
     NULLIF(all_types.text, $30),
     GREATEST(all_types.numeric, all_types.numeric_ptr),
     LEAST(all_types.numeric, all_types.numeric_ptr),
     current_database()
FROM test_sample.all_types;
`,
	}, {
		Key:   1,
		Value: []interface{}{int64(150), "TRUE", "111", "111", "111", "11.23", "11.23", "11.23", "11.23", "11.23", int64(234), "1/8/1999", "04:05:06.789", "04:05:06 PST", "1999-01-08 04:05:06", "January 8 04:05:06 1999 PST", "04:05:06", "{\"key\":\"value\"}", "HH12:MI:SS", "999", "999D9", "999D99S", "05 Dec 2000", "DD Mon YYYY", "12,454", "99G999D9S", "05 Dec 2000", "DD Mon YYYY", int64(11), "(none)"},
	}})
	gotestparrot.R.Load("TestExpressionOperators", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT all_types.integer IS NULL AS "result.is_null",
     all_types.date_ptr IS NOT NULL AS "result.is_not_null",
     (all_types.small_int_ptr IN ($1, $2)) AS "result.in",
     (all_types.small_int_ptr IN ((
          SELECT all_types.integer AS "all_types.integer"
          FROM test_sample.all_types
     ))) AS "result.in_select",
     (all_types.small_int_ptr NOT IN ($3, $4, NULL)) AS "result.not_in",
     (all_types.small_int_ptr NOT IN ((
          SELECT all_types.integer AS "all_types.integer"
          FROM test_sample.all_types
     ))) AS "result.not_in_select"
FROM test_sample.all_types
LIMIT $5;
`,
	}, {
		Key:   1,
		Value: []interface{}{int64(11), int64(22), int64(11), int64(22), int64(2)},
	}, {
		Key: 2,
		Value: []expressionOperatorsResult{{ExpressionTestResult: common.ExpressionTestResult{
			In:          gotestparrot.Ptr(false).(*bool),
			InSelect:    gotestparrot.Ptr(false).(*bool),
			IsNotNull:   gotestparrot.Ptr(true).(*bool),
			IsNull:      gotestparrot.Ptr(false).(*bool),
			NotInSelect: gotestparrot.Ptr(true).(*bool),
		}}, {ExpressionTestResult: common.ExpressionTestResult{
			IsNotNull: gotestparrot.Ptr(false).(*bool),
			IsNull:    gotestparrot.Ptr(false).(*bool),
		}}},
	}})
	gotestparrot.R.Load("TestFloatOperators", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT (all_types.numeric = all_types.numeric) AS "eq1",
     (all_types.decimal = $1) AS "eq2",
     (all_types.real = $2) AS "eq3",
     (all_types.numeric IS DISTINCT FROM all_types.numeric) AS "distinct1",
     (all_types.decimal IS DISTINCT FROM $3) AS "distinct2",
     (all_types.real IS DISTINCT FROM $4) AS "distinct3",
     (all_types.numeric IS NOT DISTINCT FROM all_types.numeric) AS "not_distinct1",
     (all_types.decimal IS NOT DISTINCT FROM $5) AS "not_distinct2",
     (all_types.real IS NOT DISTINCT FROM $6) AS "not_distinct3",
     (all_types.numeric < $7) AS "lt1",
     (all_types.numeric < $8) AS "lt2",
     (all_types.numeric > $9) AS "gt1",
     (all_types.numeric > $10) AS "gt2",
     TRUNC((all_types.decimal + all_types.decimal), $11) AS "add1",
     TRUNC((all_types.decimal + $12), $13) AS "add2",
     TRUNC((all_types.decimal - all_types.decimal_ptr), $14) AS "sub1",
     TRUNC((all_types.decimal - $15), $16) AS "sub2",
     TRUNC((all_types.decimal * all_types.decimal_ptr), $17) AS "mul1",
     TRUNC((all_types.decimal * $18), $19) AS "mul2",
     TRUNC((all_types.decimal / all_types.decimal_ptr), $20) AS "div1",
     TRUNC((all_types.decimal / $21), $22) AS "div2",
     TRUNC((all_types.decimal % all_types.decimal_ptr), $23) AS "mod1",
     TRUNC((all_types.decimal % $24), $25) AS "mod2",
     TRUNC(POW(all_types.decimal, all_types.decimal_ptr), $26) AS "pow1",
     TRUNC(POW(all_types.decimal, $27), $28) AS "pow2",
     TRUNC(ABS(all_types.decimal), $29) AS "abs",
     TRUNC(POWER(all_types.decimal, $30), $31) AS "power",
     TRUNC(SQRT(all_types.decimal), $32) AS "sqrt",
     TRUNC(CBRT(all_types.decimal)::decimal, $33) AS "cbrt",
     CEIL(all_types.real) AS "ceil",
     FLOOR(all_types.real) AS "floor",
     ROUND(all_types.decimal) AS "round1",
     ROUND(all_types.decimal, all_types.integer) AS "round2",
     SIGN(all_types.real) AS "sign",
     TRUNC(all_types.decimal, $34) AS "trunc"
FROM test_sample.all_types
LIMIT $35;
`,
	}, {
		Key:   1,
		Value: []interface{}{12.22, 12.12, 12.0, 12.12, 12.0, 12.12, 124.0, 34.56, 124.0, 34.56, int64(2), 11.22, int64(2), int64(2), 11.22, int64(2), int64(2), 11.22, int64(2), int64(2), 11.22, int64(2), int64(2), 11.22, int64(2), int64(2), 2.1, int64(2), int64(2), 2.1, int64(2), int64(2), int64(2), int64(1), int64(2)},
	}, {
		Key: 2,
		Value: []floatOperatorsResult{{FloatExpressionTestResult: common.FloatExpressionTestResult{
			Abs:          gotestparrot.Ptr(1.11).(*float64),
			Add1:         gotestparrot.Ptr(2.22).(*float64),
			Add2:         gotestparrot.Ptr(12.33).(*float64),
			Cbrt:         gotestparrot.Ptr(1.03).(*float64),
			Ceil:         gotestparrot.Ptr(6.0).(*float64),
			Distinct1:    gotestparrot.Ptr(false).(*bool),
			Distinct2:    gotestparrot.Ptr(true).(*bool),
			Distinct3:    gotestparrot.Ptr(true).(*bool),
			Div1:         gotestparrot.Ptr(1.0).(*float64),
			Div2:         gotestparrot.Ptr(0.09).(*float64),
			Eq1:          gotestparrot.Ptr(true).(*bool),
			Eq2:          gotestparrot.Ptr(false).(*bool),
			Eq3:          gotestparrot.Ptr(false).(*bool),
			Floor:        gotestparrot.Ptr(5.0).(*float64),
			Gt1:          gotestparrot.Ptr(false).(*bool),
			Gt2:          gotestparrot.Ptr(false).(*bool),
			Lt1:          gotestparrot.Ptr(true).(*bool),
			Lt2:          gotestparrot.Ptr(true).(*bool),
			Mod1:         gotestparrot.Ptr(0.0).(*float64),
			Mod2:         gotestparrot.Ptr(1.11).(*float64),
			Mul1:         gotestparrot.Ptr(1.23).(*float64),
			Mul2:         gotestparrot.Ptr(12.45).(*float64),
			NotDistinct1: gotestparrot.Ptr(true).(*bool),
			NotDistinct2: gotestparrot.Ptr(false).(*bool),
			NotDistinct3: gotestparrot.Ptr(false).(*bool),
			Pow1:         gotestparrot.Ptr(1.12).(*float64),
			Pow2:         gotestparrot.Ptr(1.24).(*float64),
			Power:        gotestparrot.Ptr(1.24).(*float64),
			Round1:       gotestparrot.Ptr(1.0).(*float64),
			Round2:       gotestparrot.Ptr(1.11).(*float64),
			Sign:         gotestparrot.Ptr(1.0).(*float64),
			Sqrt:         gotestparrot.Ptr(1.05).(*float64),
			Sub1:         gotestparrot.Ptr(0.0).(*float64),
			Sub2:         gotestparrot.Ptr(-10.11).(*float64),
			Trunc:        gotestparrot.Ptr(1.1).(*float64),
		}}, {FloatExpressionTestResult: common.FloatExpressionTestResult{
			Abs:          gotestparrot.Ptr(1.11).(*float64),
			Add1:         gotestparrot.Ptr(2.22).(*float64),
			Add2:         gotestparrot.Ptr(12.33).(*float64),
			Cbrt:         gotestparrot.Ptr(1.03).(*float64),
			Ceil:         gotestparrot.Ptr(6.0).(*float64),
			Distinct1:    gotestparrot.Ptr(false).(*bool),
			Distinct2:    gotestparrot.Ptr(true).(*bool),
			Distinct3:    gotestparrot.Ptr(true).(*bool),
			Div2:         gotestparrot.Ptr(0.09).(*float64),
			Eq1:          gotestparrot.Ptr(true).(*bool),
			Eq2:          gotestparrot.Ptr(false).(*bool),
			Eq3:          gotestparrot.Ptr(false).(*bool),
			Floor:        gotestparrot.Ptr(5.0).(*float64),
			Gt1:          gotestparrot.Ptr(false).(*bool),
			Gt2:          gotestparrot.Ptr(false).(*bool),
			Lt1:          gotestparrot.Ptr(true).(*bool),
			Lt2:          gotestparrot.Ptr(true).(*bool),
			Mod2:         gotestparrot.Ptr(1.11).(*float64),
			Mul2:         gotestparrot.Ptr(12.45).(*float64),
			NotDistinct1: gotestparrot.Ptr(true).(*bool),
			NotDistinct2: gotestparrot.Ptr(false).(*bool),
			NotDistinct3: gotestparrot.Ptr(false).(*bool),
			Pow2:         gotestparrot.Ptr(1.24).(*float64),
			Power:        gotestparrot.Ptr(1.24).(*float64),
			Round1:       gotestparrot.Ptr(1.0).(*float64),
			Round2:       gotestparrot.Ptr(1.11).(*float64),
			Sign:         gotestparrot.Ptr(1.0).(*float64),
			Sqrt:         gotestparrot.Ptr(1.05).(*float64),
			Sub2:         gotestparrot.Ptr(-10.11).(*float64),
			Trunc:        gotestparrot.Ptr(1.1).(*float64),
		}}},
	}})
	gotestparrot.R.Load("TestIntegerOperators", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT all_types.big_int AS "all_types.big_int",
     all_types.big_int_ptr AS "all_types.big_int_ptr",
     all_types.small_int AS "all_types.small_int",
     all_types.small_int_ptr AS "all_types.small_int_ptr",
     (all_types.big_int = all_types.big_int) AS "eq1",
     (all_types.big_int = $1) AS "eq2",
     (all_types.big_int != all_types.big_int_ptr) AS "neq1",
     (all_types.big_int != $2) AS "neq2",
     (all_types.big_int IS DISTINCT FROM all_types.big_int) AS "distinct1",
     (all_types.big_int IS DISTINCT FROM $3) AS "distinct2",
     (all_types.big_int IS NOT DISTINCT FROM all_types.big_int) AS "not distinct1",
     (all_types.big_int IS NOT DISTINCT FROM $4) AS "not distinct2",
     (all_types.big_int < all_types.big_int_ptr) AS "lt1",
     (all_types.big_int < $5) AS "lt2",
     (all_types.big_int <= all_types.big_int_ptr) AS "lte1",
     (all_types.big_int <= $6) AS "lte2",
     (all_types.big_int > all_types.big_int_ptr) AS "gt1",
     (all_types.big_int > $7) AS "gt2",
     (all_types.big_int >= all_types.big_int_ptr) AS "gte1",
     (all_types.big_int >= $8) AS "gte2",
     (all_types.big_int + all_types.big_int) AS "add1",
     (all_types.big_int + $9) AS "add2",
     (all_types.big_int - all_types.big_int) AS "sub1",
     (all_types.big_int - $10) AS "sub2",
     (all_types.big_int * all_types.big_int) AS "mul1",
     (all_types.big_int * $11) AS "mul2",
     (all_types.big_int / all_types.big_int) AS "div1",
     (all_types.big_int / $12) AS "div2",
     (all_types.big_int % all_types.big_int) AS "mod1",
     (all_types.big_int % $13) AS "mod2",
     POW(all_types.small_int, (all_types.small_int / $14)) AS "pow1",
     POW(all_types.small_int, $15) AS "pow2",
     (all_types.small_int & all_types.small_int) AS "bit_and1",
     (all_types.small_int & all_types.small_int) AS "bit_and2",
     (all_types.small_int | all_types.small_int) AS "bit or 1",
     (all_types.small_int | $16) AS "bit or 2",
     (all_types.small_int # all_types.small_int) AS "bit xor 1",
     (all_types.small_int # $17) AS "bit xor 2",
     (~ ($18 * all_types.small_int)) AS "bit_not_1",
     (~ -11) AS "bit_not_2",
     (all_types.small_int << (all_types.small_int / $19)) AS "bit shift left 1",
     (all_types.small_int << $20) AS "bit shift left 2",
     (all_types.small_int >> (all_types.small_int / $21)) AS "bit shift right 1",
     (all_types.small_int >> $22) AS "bit shift right 2",
     ABS(all_types.big_int) AS "abs",
     SQRT(ABS(all_types.big_int)) AS "sqrt",
     CBRT(ABS(all_types.big_int)) AS "cbrt"
FROM test_sample.all_types
LIMIT $23;
`,
	}, {
		Key:   1,
		Value: []interface{}{int64(12), int64(12), int64(12), int64(12), int64(65), int64(65), int64(65), int64(65), int64(11), int64(11), int64(11), int64(11), int64(11), int64(3), int64(6), int64(22), int64(11), int64(-1), int64(2), int64(4), int64(5), int64(1), int64(2)},
	}, {
		Key: 2,
		Value: []integerOperatorsResult{{AllTypesIntegerExpResult: common.AllTypesIntegerExpResult{
			Add1:           gotestparrot.Ptr(int64(10000)).(*int64),
			Add2:           gotestparrot.Ptr(int64(5011)).(*int64),
			BitAnd1:        gotestparrot.Ptr(int64(14)).(*int64),
			BitAnd2:        gotestparrot.Ptr(int64(14)).(*int64),
			BitOr1:         gotestparrot.Ptr(int64(14)).(*int64),
			BitOr2:         gotestparrot.Ptr(int64(30)).(*int64),
			BitShiftLeft1:  gotestparrot.Ptr(int64(1792)).(*int64),
			BitShiftLeft2:  gotestparrot.Ptr(int64(224)).(*int64),
			BitShiftRight1: gotestparrot.Ptr(int64(3)).(*int64),
			BitShiftRight2: gotestparrot.Ptr(int64(7)).(*int64),
			BitXor1:        gotestparrot.Ptr(int64(0)).(*int64),
			BitXor2:        gotestparrot.Ptr(int64(5)).(*int64),
			Div1:           gotestparrot.Ptr(int64(1)).(*int64),
			Div2:           gotestparrot.Ptr(int64(454)).(*int64),
			EqualityExpResult: common.EqualityExpResult{
				Distinct1:    gotestparrot.Ptr(false).(*bool),
				Distinct2:    gotestparrot.Ptr(true).(*bool),
				Eq1:          gotestparrot.Ptr(true).(*bool),
				Eq2:          gotestparrot.Ptr(false).(*bool),
				Gt1:          gotestparrot.Ptr(false).(*bool),
				Gt2:          gotestparrot.Ptr(true).(*bool),
				Gte1:         gotestparrot.Ptr(false).(*bool),
				Gte2:         gotestparrot.Ptr(true).(*bool),
				Lt1:          gotestparrot.Ptr(true).(*bool),
				Lt2:          gotestparrot.Ptr(false).(*bool),
				Lte1:         gotestparrot.Ptr(true).(*bool),
				Lte2:         gotestparrot.Ptr(false).(*bool),
				NotDistinct1: gotestparrot.Ptr(true).(*bool),
				NotDistinct2: gotestparrot.Ptr(false).(*bool),
			},
			Mod1: gotestparrot.Ptr(int64(0)).(*int64),
			Mod2: gotestparrot.Ptr(int64(6)).(*int64),
			Mul1: gotestparrot.Ptr(int64(25000000)).(*int64),
			Mul2: gotestparrot.Ptr(int64(55000)).(*int64),
			Pow1: gotestparrot.Ptr(int64(38416)).(*int64),
			Pow2: gotestparrot.Ptr(int64(7529536)).(*int64),
			Sub1: gotestparrot.Ptr(int64(0)).(*int64),
			Sub2: gotestparrot.Ptr(int64(4989)).(*int64),
		}}, {AllTypesIntegerExpResult: common.AllTypesIntegerExpResult{
			Add1:           gotestparrot.Ptr(int64(10000)).(*int64),
			Add2:           gotestparrot.Ptr(int64(5011)).(*int64),
			BitAnd1:        gotestparrot.Ptr(int64(14)).(*int64),
			BitAnd2:        gotestparrot.Ptr(int64(14)).(*int64),
			BitOr1:         gotestparrot.Ptr(int64(14)).(*int64),
			BitOr2:         gotestparrot.Ptr(int64(30)).(*int64),
			BitShiftLeft1:  gotestparrot.Ptr(int64(1792)).(*int64),
			BitShiftLeft2:  gotestparrot.Ptr(int64(224)).(*int64),
			BitShiftRight1: gotestparrot.Ptr(int64(3)).(*int64),
			BitShiftRight2: gotestparrot.Ptr(int64(7)).(*int64),
			BitXor1:        gotestparrot.Ptr(int64(0)).(*int64),
			BitXor2:        gotestparrot.Ptr(int64(5)).(*int64),
			Div1:           gotestparrot.Ptr(int64(1)).(*int64),
			Div2:           gotestparrot.Ptr(int64(454)).(*int64),
			EqualityExpResult: common.EqualityExpResult{
				Distinct1:    gotestparrot.Ptr(false).(*bool),
				Distinct2:    gotestparrot.Ptr(true).(*bool),
				Eq1:          gotestparrot.Ptr(true).(*bool),
				Eq2:          gotestparrot.Ptr(false).(*bool),
				Gt2:          gotestparrot.Ptr(true).(*bool),
				Gte2:         gotestparrot.Ptr(true).(*bool),
				Lt2:          gotestparrot.Ptr(false).(*bool),
				Lte2:         gotestparrot.Ptr(false).(*bool),
				NotDistinct1: gotestparrot.Ptr(true).(*bool),
				NotDistinct2: gotestparrot.Ptr(false).(*bool),
			},
			Mod1: gotestparrot.Ptr(int64(0)).(*int64),
			Mod2: gotestparrot.Ptr(int64(6)).(*int64),
			Mul1: gotestparrot.Ptr(int64(25000000)).(*int64),
			Mul2: gotestparrot.Ptr(int64(55000)).(*int64),
			Pow1: gotestparrot.Ptr(int64(38416)).(*int64),
			Pow2: gotestparrot.Ptr(int64(7529536)).(*int64),
			Sub1: gotestparrot.Ptr(int64(0)).(*int64),
			Sub2: gotestparrot.Ptr(int64(4989)).(*int64),
		}}},
	}})
	gotestparrot.R.Load("TestInterval", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT INTERVAL '1 YEAR',
     INTERVAL '1 MONTH',
     INTERVAL '1 WEEK',
     INTERVAL '1 DAY',
     INTERVAL '1 HOUR',
     INTERVAL '1 MINUTE',
     INTERVAL '1 SECOND',
     INTERVAL '1 MILLISECOND',
     INTERVAL '1 MICROSECOND',
     INTERVAL '1 DECADE',
     INTERVAL '1 CENTURY',
     INTERVAL '1 MILLENNIUM',
     INTERVAL '1 YEAR 10 MONTH',
     INTERVAL '1 YEAR 10 MONTH 20 DAY',
     INTERVAL '1 YEAR 10 MONTH 20 DAY 3 HOUR',
     INTERVAL '1 YEAR' IS NOT NULL,
     INTERVAL '1 YEAR' AS "one year",
     INTERVAL '0 MICROSECOND',
     INTERVAL '1 MICROSECOND',
     INTERVAL '1000 MICROSECOND',
     INTERVAL '1 SECOND',
     INTERVAL '1 MINUTE',
     INTERVAL '1 HOUR',
     INTERVAL '1 DAY',
     INTERVAL '1 DAY 2 HOUR 3 MINUTE 4 SECOND 5 MICROSECOND',
     (all_types.interval = INTERVAL '2 HOUR 20 MINUTE') = $1,
     (all_types.interval_ptr != INTERVAL '2 HOUR 20 MINUTE') = $2,
     (all_types.interval IS DISTINCT FROM INTERVAL '2 HOUR 20 MINUTE') = all_types.boolean,
     (all_types.interval_ptr IS NOT DISTINCT FROM INTERVAL '10 MICROSECOND') = all_types.boolean,
     (all_types.interval < all_types.interval_ptr) = all_types.boolean_ptr,
     (all_types.interval <= all_types.interval_ptr) = all_types.boolean_ptr,
     (all_types.interval > all_types.interval_ptr) = all_types.boolean_ptr,
     (all_types.interval >= all_types.interval_ptr) = all_types.boolean_ptr,
     (all_types.interval + all_types.interval_ptr) = INTERVAL '17 SECOND',
     (all_types.interval - all_types.interval_ptr) = INTERVAL '100 MICROSECOND',
     (all_types.interval_ptr * $3) = all_types.interval,
     (all_types.interval_ptr / $4) = all_types.interval_ptr
FROM test_sample.all_types;
`,
	}, {
		Key:   1,
		Value: []interface{}{true, false, int64(11), 22.222},
	}})
	gotestparrot.R.Load("TestJSONBOperators", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT $1::jsonb AS "jsonb",
     $2::jsonb AS "jsonb_array",
     ($3::jsonb -> $4) AS "extract",
     ($5::jsonb ->> $6) AS "extract_text",
     ($7::jsonb #> $8::text[]) AS "extract_path",
     ($9::jsonb #>> $10::text[]) AS "extract_path_text",
     ($11::jsonb @> $12::jsonb) AS "contains",
     ($13::jsonb <@ $14::jsonb) AS "contains",
     ($15::jsonb ? $16) AS "has_key",
     ($17::jsonb ?| $18::text[]) AS "has_any_key",
     ($19::jsonb ?& $20::text[]) AS "has_keys",
     ($21::jsonb || $22::jsonb) AS "concat",
     ($23::jsonb - $24) AS "delete_key",
     ($25::jsonb - $26) AS "delete_index",
     ($27::jsonb #- $28::text[]) AS "delete",
     jsonb_array_length($29::jsonb) AS "array_len",
     jsonb_typeof($30::jsonb) AS "typeof",
     to_jsonb($31::text[]) AS "to_jsonb",
     jsonb_build_array($32::text, $33::integer, $34::numeric, $35::jsonb) AS "jsonb_build_array",
     jsonb_build_object($36::text, $37::text, $38::text, $39::integer, $40::text, $41::numeric, $42::text, $43::jsonb, $44::text, jsonb_build_object($45::text, $46::text, $47::text, $48::integer)) AS "jsonb_build_object"
FROM test_sample.all_types
LIMIT $49;
`,
	}, {
		Key:   1,
		Value: []interface{}{"{\"key\":\"value\",\"key2\":[0,1,2]}", "[\"a\",\"b\"]", "{\"key\":\"value\",\"key2\":[0,1,2]}", "key", "{\"key\":\"value\",\"key2\":[0,1,2]}", "key", "{\"key\":\"value\",\"key2\":[0,1,2]}", gotestparrot.Ptr(pq.StringArray{"key"}).(*pq.StringArray), "{\"key\":\"value\",\"key2\":[0,1,2]}", gotestparrot.Ptr(pq.StringArray{"key2", "0"}).(*pq.StringArray), "{\"key\":\"value\",\"key2\":[0,1,2]}", "{\"key\":\"value\",\"key2\":[0,1,2]}", "{\"key\":\"value\",\"key2\":[0,1,2]}", "{\"key\":\"value\",\"key2\":[0,1,2]}", "{\"key\":\"value\",\"key2\":[0,1,2]}", "key", "{\"key\":\"value\",\"key2\":[0,1,2]}", gotestparrot.Ptr(pq.StringArray{"key", "key3"}).(*pq.StringArray), "{\"key\":\"value\",\"key2\":[0,1,2]}", gotestparrot.Ptr(pq.StringArray{"key", "key3"}).(*pq.StringArray), "{\"key\":\"value\",\"key2\":[0,1,2]}", "{\"key3\":\"value3\"}", "{\"key\":\"value\",\"key2\":[0,1,2]}", "key2", "[\"a\",\"b\"]", int64(1), "{\"key\":\"value\",\"key2\":[0,1,2]}", gotestparrot.Ptr(pq.StringArray{"key2", "0"}).(*pq.StringArray), "[\"a\",\"b\"]", "[\"a\",\"b\"]", gotestparrot.Ptr(pq.StringArray{"elem1", "elem2"}).(*pq.StringArray), "2", int64(2), 2.2, "{\"key\":\"value\"}", "text", "2", "int", int64(2), "real", 2.2, "jsonb", "{\"key\":\"value\"}", "subobject", "key1", "value1", "key2", int64(2), int64(1)},
	}, {
		Key: 2,
		Value: jsonbResult{
			ArrayLen:         2,
			Concat:           gotestparrot.Decode("{\"key\": \"value\", \"key2\": [0, 1, 2], \"key3\": \"value3\"}", qrm.JSON{}).(qrm.JSON),
			Contains:         true,
			Delete:           gotestparrot.Decode("{\"key\": \"value\", \"key2\": [1, 2]}", qrm.JSON{}).(qrm.JSON),
			DeleteIndex:      gotestparrot.Decode("[\"a\", \"b\"]", qrm.JSON{}).(qrm.JSON),
			DeleteKey:        gotestparrot.Decode("{\"key\": \"value\"}", qrm.JSON{}).(qrm.JSON),
			Extract:          gotestparrot.Decode("\"value\"", qrm.JSON{}).(qrm.JSON),
			ExtractPath:      gotestparrot.Decode("\"value\"", qrm.JSON{}).(qrm.JSON),
			ExtractPathText:  "0",
			ExtractText:      "value",
			HasAnyKey:        true,
			HasKey:           true,
			JSONB:            gotestparrot.Decode("{\"key\": \"value\", \"key2\": [0, 1, 2]}", qrm.JSON{}).(qrm.JSON),
			JSONBArray:       gotestparrot.Decode("[\"a\", \"b\"]", qrm.JSON{}).(qrm.JSON),
			JSONBBuildArray:  gotestparrot.Decode("[\"2\", 2, 2.2, {\"key\": \"value\"}]", qrm.JSON{}).(qrm.JSON),
			JSONBBuildObject: gotestparrot.Decode("{\"int\": 2, \"real\": 2.2, \"text\": \"2\", \"jsonb\": {\"key\": \"value\"}, \"subobject\": {\"key1\": \"value1\", \"key2\": 2}}", qrm.JSON{}).(qrm.JSON),
			ToJSONB:          gotestparrot.Decode("[\"elem1\", \"elem2\"]", qrm.JSON{}).(qrm.JSON),
			TypeOf:           "array",
		},
	}})
	gotestparrot.R.Load("TestStringOperators", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT all_types.text = all_types.char,
     all_types.text = $1,
     all_types.text != all_types.var_char_ptr,
     all_types.text != $2,
     all_types.text > all_types.text,
     all_types.text > $3,
     all_types.text >= all_types.text_ptr,
     all_types.text >= $4,
     all_types.text < all_types.char,
     all_types.text < $5,
     all_types.text <= all_types.var_char,
     all_types.text <= $6,
     all_types.text || $7,
     all_types.text || $8,
     all_types.text LIKE $9,
     all_types.text NOT LIKE $10,
     all_types.text ~* $11,
     all_types.text ~ $12,
     all_types.text !~* $13,
     all_types.text !~ $14,
     BIT_LENGTH($15),
     CHAR_LENGTH(all_types.char),
     CHAR_LENGTH($16),
     OCTET_LENGTH(all_types.text),
     OCTET_LENGTH($17),
     LOWER(all_types.var_char_ptr),
     LOWER($18),
     UPPER(all_types.char),
     UPPER($19),
     BTRIM(all_types.var_char),
     BTRIM($20),
     BTRIM(all_types.var_char, $21),
     BTRIM($22, $23),
     LTRIM(all_types.var_char),
     LTRIM($24),
     LTRIM(all_types.var_char, $25),
     LTRIM($26, $27),
     RTRIM($28),
     RTRIM(all_types.var_char, $29),
     CHR($30),
     CONCAT(all_types.var_char_ptr, all_types.var_char_ptr, $31::text, $32::integer),
     CONCAT($33::boolean, $34::integer, $35::numeric, $36::text),
     CONCAT_WS($37::text, $38::integer, $39::numeric, $40::text, $41::boolean),
     CONVERT($42, $43, $44),
     CONVERT(all_types.bytea, $45, $46),
     CONVERT_FROM($47, $48),
     CONVERT_TO($49, $50),
     DECODE($51, $52),
     FORMAT($53, $54::text),
     INITCAP($55),
     LEFT($56, $57),
     RIGHT($58, $59),
     LENGTH($60),
     LENGTH($61, $62),
     LPAD($63, $64),
     LPAD($65, $66, $67),
     RPAD($68, $69),
     RPAD($70, $71, $72),
     MD5(all_types.var_char),
     REPEAT(all_types.text, $73),
     REPLACE(all_types.char, $74, $75),
     REVERSE(all_types.var_char),
     STRPOS(all_types.text, $76),
     SUBSTR(all_types.char, $77),
     SUBSTR(all_types.char_ptr, $78, $79),
     TO_HEX(all_types.integer_ptr)
FROM test_sample.all_types;
`,
	}, {
		Key:   1,
		Value: []interface{}{"Text", "Text", "Text", "Text", "Text", "Text", "text2", int64(11), "abc", "_b_", "^t", "^t", "^t", "^t", "length", "length", "length", "length", "upper", "btrim", "AA", "btrim", "AA", "ltrim", "A", "Ltrim", "A", "rtrim", "B", int64(65), "aaa", int64(1), false, int64(1), 22.2, "test test", "string1", int64(1), 11.22, "bytea", false, "bytea", "UTF8", "LATIN1", "UTF8", "LATIN1", "text_in_utf8", "UTF8", "text_in_utf8", "UTF8", "MTIzAAE=", "base64", "Hello %s, %1$s", "World", "hi THOMAS", "abcde", int64(2), "abcde", int64(2), "jose", "jose", "UTF8", "Hi", int64(5), "Hi", int64(5), "xy", "Hi", int64(5), "Hi", int64(5), "xy", int64(33), "BA", "AB", "A", int64(3), int64(3), int64(2)},
	}})
	gotestparrot.R.Load("TestSubQueryColumnReference", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT "subQuery"."all_types.boolean" AS "all_types.boolean",
     "subQuery"."all_types.integer" AS "all_types.integer",
     "subQuery"."all_types.real" AS "all_types.real",
     "subQuery"."all_types.text" AS "all_types.text",
     "subQuery"."all_types.time" AS "all_types.time",
     "subQuery"."all_types.timez" AS "all_types.timez",
     "subQuery"."all_types.timestamp" AS "all_types.timestamp",
     "subQuery"."all_types.timestampz" AS "all_types.timestampz",
     "subQuery"."all_types.date" AS "all_types.date",
     "subQuery"."aliasedColumn" AS "aliasedColumn"
FROM (
          SELECT all_types.boolean AS "all_types.boolean",
               all_types.integer AS "all_types.integer",
               all_types.real AS "all_types.real",
               all_types.text AS "all_types.text",
               all_types.time AS "all_types.time",
               all_types.timez AS "all_types.timez",
               all_types.timestamp AS "all_types.timestamp",
               all_types.timestampz AS "all_types.timestampz",
               all_types.date AS "all_types.date",
               all_types.bytea AS "aliasedColumn"
          FROM test_sample.all_types
          LIMIT 2
     ) AS "subQuery";
`,
	}, {
		Key: 1,
		Value: []model.AllTypes{{
			Date:       gotestparrot.Decode("1999-01-08T00:00:00Z", time.Time{}).(time.Time),
			Integer:    int32(300),
			Real:       float32(5.55),
			Text:       "Some text",
			Time:       gotestparrot.Decode("0000-01-01T04:05:06Z", time.Time{}).(time.Time),
			Timestamp:  gotestparrot.Decode("1999-01-08T04:05:06Z", time.Time{}).(time.Time),
			Timestampz: gotestparrot.Decode("1999-01-08T12:05:06Z", time.Time{}).(time.Time),
			Timez:      gotestparrot.Decode("0000-01-01T04:05:06-08:00", time.Time{}).(time.Time),
		}, {
			Date:       gotestparrot.Decode("1999-01-08T00:00:00Z", time.Time{}).(time.Time),
			Integer:    int32(300),
			Real:       float32(5.55),
			Text:       "Some text",
			Time:       gotestparrot.Decode("0000-01-01T04:05:06Z", time.Time{}).(time.Time),
			Timestamp:  gotestparrot.Decode("1999-01-08T04:05:06Z", time.Time{}).(time.Time),
			Timestampz: gotestparrot.Decode("1999-01-08T12:05:06Z", time.Time{}).(time.Time),
			Timez:      gotestparrot.Decode("0000-01-01T04:05:06-08:00", time.Time{}).(time.Time),
		}},
	}, {
		Key: 2,
		Value: `
SELECT "subQuery"."all_types.boolean" AS "all_types.boolean",
     "subQuery"."all_types.integer" AS "all_types.integer",
     "subQuery"."all_types.real" AS "all_types.real",
     "subQuery"."all_types.text" AS "all_types.text",
     "subQuery"."all_types.time" AS "all_types.time",
     "subQuery"."all_types.timez" AS "all_types.timez",
     "subQuery"."all_types.timestamp" AS "all_types.timestamp",
     "subQuery"."all_types.timestampz" AS "all_types.timestampz",
     "subQuery"."all_types.date" AS "all_types.date",
     "subQuery"."aliasedColumn" AS "aliasedColumn"
FROM (
          SELECT all_types.boolean AS "all_types.boolean",
               all_types.integer AS "all_types.integer",
               all_types.real AS "all_types.real",
               all_types.text AS "all_types.text",
               all_types.time AS "all_types.time",
               all_types.timez AS "all_types.timez",
               all_types.timestamp AS "all_types.timestamp",
               all_types.timestampz AS "all_types.timestampz",
               all_types.date AS "all_types.date",
               all_types.bytea AS "aliasedColumn"
          FROM test_sample.all_types
          LIMIT 2
     ) AS "subQuery";
`,
	}, {
		Key: 3,
		Value: `
SELECT "subQuery"."all_types.boolean" AS "all_types.boolean",
     "subQuery"."all_types.integer" AS "all_types.integer",
     "subQuery"."all_types.real" AS "all_types.real",
     "subQuery"."all_types.text" AS "all_types.text",
     "subQuery"."all_types.time" AS "all_types.time",
     "subQuery"."all_types.timez" AS "all_types.timez",
     "subQuery"."all_types.timestamp" AS "all_types.timestamp",
     "subQuery"."all_types.timestampz" AS "all_types.timestampz",
     "subQuery"."all_types.date" AS "all_types.date",
     "subQuery"."aliasedColumn" AS "aliasedColumn"
FROM (
          (
               SELECT all_types.boolean AS "all_types.boolean",
                    all_types.integer AS "all_types.integer",
                    all_types.real AS "all_types.real",
                    all_types.text AS "all_types.text",
                    all_types.time AS "all_types.time",
                    all_types.timez AS "all_types.timez",
                    all_types.timestamp AS "all_types.timestamp",
                    all_types.timestampz AS "all_types.timestampz",
                    all_types.date AS "all_types.date",
                    all_types.bytea AS "aliasedColumn"
               FROM test_sample.all_types
               LIMIT 1
          )
          UNION ALL
          (
               SELECT all_types.boolean AS "all_types.boolean",
                    all_types.integer AS "all_types.integer",
                    all_types.real AS "all_types.real",
                    all_types.text AS "all_types.text",
                    all_types.time AS "all_types.time",
                    all_types.timez AS "all_types.timez",
                    all_types.timestamp AS "all_types.timestamp",
                    all_types.timestampz AS "all_types.timestampz",
                    all_types.date AS "all_types.date",
                    all_types.bytea AS "aliasedColumn"
               FROM test_sample.all_types
               LIMIT 1
               OFFSET 1
          )
     ) AS "subQuery";
`,
	}, {
		Key: 4,
		Value: []model.AllTypes{{
			Date:       gotestparrot.Decode("1999-01-08T00:00:00Z", time.Time{}).(time.Time),
			Integer:    int32(300),
			Real:       float32(5.55),
			Text:       "Some text",
			Time:       gotestparrot.Decode("0000-01-01T04:05:06Z", time.Time{}).(time.Time),
			Timestamp:  gotestparrot.Decode("1999-01-08T04:05:06Z", time.Time{}).(time.Time),
			Timestampz: gotestparrot.Decode("1999-01-08T12:05:06Z", time.Time{}).(time.Time),
			Timez:      gotestparrot.Decode("0000-01-01T04:05:06-08:00", time.Time{}).(time.Time),
		}, {
			Date:       gotestparrot.Decode("1999-01-08T00:00:00Z", time.Time{}).(time.Time),
			Integer:    int32(300),
			Real:       float32(5.55),
			Text:       "Some text",
			Time:       gotestparrot.Decode("0000-01-01T04:05:06Z", time.Time{}).(time.Time),
			Timestamp:  gotestparrot.Decode("1999-01-08T04:05:06Z", time.Time{}).(time.Time),
			Timestampz: gotestparrot.Decode("1999-01-08T12:05:06Z", time.Time{}).(time.Time),
			Timez:      gotestparrot.Decode("0000-01-01T04:05:06-08:00", time.Time{}).(time.Time),
		}},
	}, {
		Key: 5,
		Value: `
SELECT "subQuery"."all_types.boolean" AS "all_types.boolean",
     "subQuery"."all_types.integer" AS "all_types.integer",
     "subQuery"."all_types.real" AS "all_types.real",
     "subQuery"."all_types.text" AS "all_types.text",
     "subQuery"."all_types.time" AS "all_types.time",
     "subQuery"."all_types.timez" AS "all_types.timez",
     "subQuery"."all_types.timestamp" AS "all_types.timestamp",
     "subQuery"."all_types.timestampz" AS "all_types.timestampz",
     "subQuery"."all_types.date" AS "all_types.date",
     "subQuery"."aliasedColumn" AS "aliasedColumn"
FROM (
          (
               SELECT all_types.boolean AS "all_types.boolean",
                    all_types.integer AS "all_types.integer",
                    all_types.real AS "all_types.real",
                    all_types.text AS "all_types.text",
                    all_types.time AS "all_types.time",
                    all_types.timez AS "all_types.timez",
                    all_types.timestamp AS "all_types.timestamp",
                    all_types.timestampz AS "all_types.timestampz",
                    all_types.date AS "all_types.date",
                    all_types.bytea AS "aliasedColumn"
               FROM test_sample.all_types
               LIMIT 1
          )
          UNION ALL
          (
               SELECT all_types.boolean AS "all_types.boolean",
                    all_types.integer AS "all_types.integer",
                    all_types.real AS "all_types.real",
                    all_types.text AS "all_types.text",
                    all_types.time AS "all_types.time",
                    all_types.timez AS "all_types.timez",
                    all_types.timestamp AS "all_types.timestamp",
                    all_types.timestampz AS "all_types.timestampz",
                    all_types.date AS "all_types.date",
                    all_types.bytea AS "aliasedColumn"
               FROM test_sample.all_types
               LIMIT 1
               OFFSET 1
          )
     ) AS "subQuery";
`,
	}})
	gotestparrot.R.Load("TestTimeExpression", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT all_types.time = all_types.time,
     all_types.time = $1::time without time zone,
     all_types.timez = all_types.timez_ptr,
     all_types.timez = $2::time with time zone,
     all_types.timestamp = all_types.timestamp_ptr,
     all_types.timestamp = $3::timestamp without time zone,
     all_types.timestampz = all_types.timestampz_ptr,
     all_types.timestampz = $4::timestamp with time zone,
     all_types.date = all_types.date_ptr,
     all_types.date = $5::date,
     all_types.time != all_types.time,
     all_types.time != $6::time without time zone,
     all_types.timez != all_types.timez_ptr,
     all_types.timez != $7::time with time zone,
     all_types.timestamp != all_types.timestamp_ptr,
     all_types.timestamp != $8::timestamp without time zone,
     all_types.timestampz != all_types.timestampz_ptr,
     all_types.timestampz != $9::timestamp with time zone,
     all_types.date != all_types.date_ptr,
     all_types.date != $10::date,
     all_types.time IS DISTINCT FROM all_types.time,
     all_types.time IS DISTINCT FROM $11::time without time zone,
     all_types.time IS NOT DISTINCT FROM all_types.time,
     all_types.time IS NOT DISTINCT FROM $12::time without time zone,
     all_types.time < all_types.time,
     all_types.time < $13::time without time zone,
     all_types.time <= all_types.time,
     all_types.time <= $14::time without time zone,
     all_types.time > all_types.time,
     all_types.time > $15::time without time zone,
     all_types.time >= all_types.time,
     all_types.time >= $16::time without time zone,
     all_types.date + INTERVAL '1 HOUR',
     all_types.date - INTERVAL '1 MINUTE',
     all_types.time + INTERVAL '1 HOUR',
     all_types.time - INTERVAL '1 MINUTE',
     all_types.timez + INTERVAL '1 HOUR',
     all_types.timez - INTERVAL '1 MINUTE',
     all_types.timestamp + INTERVAL '1 HOUR',
     all_types.timestamp - INTERVAL '1 MINUTE',
     all_types.timestampz + INTERVAL '1 HOUR',
     all_types.timestampz - INTERVAL '1 MINUTE',
     all_types.date - $17::interval,
     CURRENT_DATE,
     CURRENT_TIME,
     CURRENT_TIME(2),
     CURRENT_TIMESTAMP,
     CURRENT_TIMESTAMP(1),
     LOCALTIME,
     LOCALTIME(11),
     LOCALTIMESTAMP,
     LOCALTIMESTAMP(4),
     NOW()
FROM test_sample.all_types;
`,
	}, {
		Key:   1,
		Value: []interface{}{"23:06:06.000000001", "23:06:06.000000222 +200", "2010-10-21 15:30:12.000000333", "2010-10-21 15:30:12.000000444 PST", "2010-12-03", "23:06:06.00000001", "23:06:06.000000555 +4:00", "2010-10-21 15:30:12.000000666", "2010-10-21 15:30:12.000000777 UTC", "2010-12-03", "23:06:06.0000001", "23:06:06.0000002", "23:06:06.000000022", "23:06:06.000000033", "23:06:06", "23:06:06.000000001", "04:05:06"},
	}})
	gotestparrot.R.Load("TestTimeLiterals", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT $1::date AS "date",
     $2::time without time zone AS "time",
     $3::time with time zone AS "timez",
     $4::timestamp without time zone AS "timestamp",
     $5::timestamp with time zone AS "timestampz"
FROM test_sample.all_types
LIMIT $6;
`,
	}, {
		Key:   1,
		Value: []interface{}{gotestparrot.Decode("2009-11-17T20:34:58.651387237+01:00", time.Time{}).(time.Time), gotestparrot.Decode("2009-11-17T20:34:58.651387237+01:00", time.Time{}).(time.Time), gotestparrot.Decode("2009-11-17T20:34:58.651387237+01:00", time.Time{}).(time.Time), gotestparrot.Decode("2009-11-17T20:34:58.651387237+01:00", time.Time{}).(time.Time), gotestparrot.Decode("2009-11-17T20:34:58.651387237+01:00", time.Time{}).(time.Time), int64(1)},
	}, {
		Key: 2,
		Value: timeLiteralsResult{
			Date:      gotestparrot.Decode("2009-11-17T00:00:00Z", time.Time{}).(time.Time),
			Time:      gotestparrot.Decode("0000-01-01T20:34:58.651387Z", time.Time{}).(time.Time),
			Timestamp: gotestparrot.Decode("2009-11-17T20:34:58.651387Z", time.Time{}).(time.Time),
			Timez:     gotestparrot.Decode("0000-01-01T20:34:58.651387+01:00", time.Time{}).(time.Time),
		},
	}})
}
