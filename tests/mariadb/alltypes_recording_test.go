// Code generated by testparrot. DO NOT EDIT.

package mariadb

import (
	qrm "github.com/go-jet/jet/v2/qrm"
	common "github.com/go-jet/jet/v2/tests/common"
	model "github.com/go-jet/jet/v2/tests/mysql/gen/test_sample/model"
	uuid "github.com/google/uuid"
	gotestparrot "github.com/xtruder/go-testparrot"
	"time"
)

func init() {
	gotestparrot.R.Load("TestAllTypes", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT all_types.boolean AS "all_types.boolean",
     all_types.boolean_ptr AS "all_types.boolean_ptr",
     all_types.tiny_int AS "all_types.tiny_int",
     all_types.u_tiny_int AS "all_types.u_tiny_int",
     all_types.small_int AS "all_types.small_int",
     all_types.u_small_int AS "all_types.u_small_int",
     all_types.medium_int AS "all_types.medium_int",
     all_types.u_medium_int AS "all_types.u_medium_int",
     all_types.` + "`" + `integer` + "`" + ` AS "all_types.integer",
     all_types.u_integer AS "all_types.u_integer",
     all_types.big_int AS "all_types.big_int",
     all_types.u_big_int AS "all_types.u_big_int",
     all_types.tiny_int_ptr AS "all_types.tiny_int_ptr",
     all_types.u_tiny_int_ptr AS "all_types.u_tiny_int_ptr",
     all_types.small_int_ptr AS "all_types.small_int_ptr",
     all_types.u_small_int_ptr AS "all_types.u_small_int_ptr",
     all_types.medium_int_ptr AS "all_types.medium_int_ptr",
     all_types.u_medium_int_ptr AS "all_types.u_medium_int_ptr",
     all_types.integer_ptr AS "all_types.integer_ptr",
     all_types.u_integer_ptr AS "all_types.u_integer_ptr",
     all_types.big_int_ptr AS "all_types.big_int_ptr",
     all_types.u_big_int_ptr AS "all_types.u_big_int_ptr",
     all_types.` + "`" + `decimal` + "`" + ` AS "all_types.decimal",
     all_types.decimal_ptr AS "all_types.decimal_ptr",
     all_types.` + "`" + `numeric` + "`" + ` AS "all_types.numeric",
     all_types.numeric_ptr AS "all_types.numeric_ptr",
     all_types.` + "`" + `float` + "`" + ` AS "all_types.float",
     all_types.float_ptr AS "all_types.float_ptr",
     all_types.` + "`" + `double` + "`" + ` AS "all_types.double",
     all_types.double_ptr AS "all_types.double_ptr",
     all_types.` + "`" + `real` + "`" + ` AS "all_types.real",
     all_types.real_ptr AS "all_types.real_ptr",
     all_types.bit AS "all_types.bit",
     all_types.bit_ptr AS "all_types.bit_ptr",
     all_types.time AS "all_types.time",
     all_types.time_ptr AS "all_types.time_ptr",
     all_types.date AS "all_types.date",
     all_types.date_ptr AS "all_types.date_ptr",
     all_types.date_time AS "all_types.date_time",
     all_types.date_time_ptr AS "all_types.date_time_ptr",
     all_types.timestamp AS "all_types.timestamp",
     all_types.timestamp_ptr AS "all_types.timestamp_ptr",
     all_types.year AS "all_types.year",
     all_types.year_ptr AS "all_types.year_ptr",
     all_types.` + "`" + `char` + "`" + ` AS "all_types.char",
     all_types.char_ptr AS "all_types.char_ptr",
     all_types.var_char AS "all_types.var_char",
     all_types.var_char_ptr AS "all_types.var_char_ptr",
     all_types.` + "`" + `binary` + "`" + ` AS "all_types.binary",
     all_types.binary_ptr AS "all_types.binary_ptr",
     all_types.var_binary AS "all_types.var_binary",
     all_types.var_binary_ptr AS "all_types.var_binary_ptr",
     all_types.` + "`" + `blob` + "`" + ` AS "all_types.blob",
     all_types.blob_ptr AS "all_types.blob_ptr",
     all_types.text AS "all_types.text",
     all_types.text_ptr AS "all_types.text_ptr",
     all_types.enum AS "all_types.enum",
     all_types.enum_ptr AS "all_types.enum_ptr",
     all_types.` + "`" + `set` + "`" + ` AS "all_types.set",
     all_types.set_ptr AS "all_types.set_ptr",
     all_types.json AS "all_types.json",
     all_types.json_ptr AS "all_types.json_ptr"
FROM test_sample.all_types
LIMIT ?;
`,
	}, {
		Key:   1,
		Value: []interface{}{int64(2)},
	}, {
		Key: 2,
		Value: []model.AllTypes{{
			BigInt:        int64(5000),
			BigIntPtr:     gotestparrot.Ptr(int64(50000)).(*int64),
			Binary:        []uint8{uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)},
			BinaryPtr:     gotestparrot.Ptr([]uint8{uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}).(*[]uint8),
			Bit:           "\x00\x03",
			BitPtr:        gotestparrot.Ptr("\x00\x03").(*string),
			Blob:          []uint8{uint8(0x62), uint8(0x6c), uint8(0x6f), uint8(0x62)},
			BlobPtr:       gotestparrot.Ptr([]uint8{uint8(0x62), uint8(0x6c), uint8(0x6f), uint8(0x62)}).(*[]uint8),
			BooleanPtr:    gotestparrot.Ptr(true).(*bool),
			Char:          "char",
			CharPtr:       gotestparrot.Ptr("char").(*string),
			Date:          gotestparrot.Decode("2008-07-04T00:00:00Z", time.Time{}).(time.Time),
			DatePtr:       gotestparrot.Decode("2008-07-04T00:00:00Z", &time.Time{}).(*time.Time),
			DateTime:      gotestparrot.Decode("2011-12-18T13:17:17Z", time.Time{}).(time.Time),
			DateTimePtr:   gotestparrot.Decode("2011-12-18T13:17:17Z", &time.Time{}).(*time.Time),
			Decimal:       1.11,
			DecimalPtr:    gotestparrot.Ptr(1.11).(*float64),
			Double:        4.44,
			DoublePtr:     gotestparrot.Ptr(4.44).(*float64),
			Enum:          model.AllTypesEnum("value1"),
			EnumPtr:       gotestparrot.Ptr(model.AllTypesEnumPtr("value1")).(*model.AllTypesEnumPtr),
			Float:         3.33,
			FloatPtr:      gotestparrot.Ptr(3.33).(*float64),
			Integer:       int32(-1600),
			IntegerPtr:    gotestparrot.Ptr(int32(-1600)).(*int32),
			JSON:          gotestparrot.Decode("{\"key1\": \"value1\", \"key2\": \"value2\"}", qrm.JSON{}).(qrm.JSON),
			JSONPtr:       gotestparrot.Decode("{\"key1\": \"value1\", \"key2\": \"value2\"}", &qrm.JSON{}).(*qrm.JSON),
			MediumInt:     int32(-150),
			MediumIntPtr:  gotestparrot.Ptr(int32(-150)).(*int32),
			Numeric:       2.22,
			NumericPtr:    gotestparrot.Ptr(2.22).(*float64),
			Real:          5.55,
			RealPtr:       gotestparrot.Ptr(5.55).(*float64),
			Set:           "s1",
			SetPtr:        gotestparrot.Ptr("s2").(*string),
			SmallInt:      int16(14),
			SmallIntPtr:   gotestparrot.Ptr(int16(14)).(*int16),
			Text:          "text",
			TextPtr:       gotestparrot.Ptr("text").(*string),
			Time:          gotestparrot.Decode("0000-01-01T10:11:12Z", time.Time{}).(time.Time),
			TimePtr:       gotestparrot.Decode("0000-01-01T10:11:12Z", &time.Time{}).(*time.Time),
			Timestamp:     gotestparrot.Decode("2007-12-31T23:00:01Z", time.Time{}).(time.Time),
			TimestampPtr:  gotestparrot.Decode("2007-12-31T23:00:01Z", &time.Time{}).(*time.Time),
			TinyInt:       int8(-3),
			TinyIntPtr:    gotestparrot.Ptr(int8(-3)).(*int8),
			UBigInt:       uint64(0xc350),
			UBigIntPtr:    gotestparrot.Ptr(uint64(0xc350)).(*uint64),
			UInteger:      uint32(0x640),
			UIntegerPtr:   gotestparrot.Ptr(uint32(0x640)).(*uint32),
			UMediumInt:    uint32(0x96),
			UMediumIntPtr: gotestparrot.Ptr(uint32(0x96)).(*uint32),
			USmallInt:     uint16(0xe),
			USmallIntPtr:  gotestparrot.Ptr(uint16(0xe)).(*uint16),
			UTinyInt:      uint8(0x3),
			UTinyIntPtr:   gotestparrot.Ptr(uint8(0x3)).(*uint8),
			VarBinary:     []uint8{uint8(0x76), uint8(0x61), uint8(0x72), uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79)},
			VarBinaryPtr:  gotestparrot.Ptr([]uint8{uint8(0x76), uint8(0x61), uint8(0x72), uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79)}).(*[]uint8),
			VarChar:       "varchar",
			VarCharPtr:    gotestparrot.Ptr("varchar").(*string),
			Year:          int16(2004),
			YearPtr:       gotestparrot.Ptr(int16(2004)).(*int16),
		}, {
			BigInt:     int64(5000),
			Binary:     []uint8{uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)},
			Bit:        "\x00\x03",
			Blob:       []uint8{uint8(0x62), uint8(0x6c), uint8(0x6f), uint8(0x62)},
			Char:       "char",
			Date:       gotestparrot.Decode("2008-07-04T00:00:00Z", time.Time{}).(time.Time),
			DateTime:   gotestparrot.Decode("2011-12-18T13:17:17Z", time.Time{}).(time.Time),
			Decimal:    1.11,
			Double:     4.44,
			Enum:       model.AllTypesEnum("value1"),
			Float:      3.33,
			Integer:    int32(-1600),
			JSON:       gotestparrot.Decode("{\"key1\": \"value1\", \"key2\": \"value2\"}", qrm.JSON{}).(qrm.JSON),
			MediumInt:  int32(-150),
			Numeric:    2.22,
			Real:       5.55,
			Set:        "s1",
			SmallInt:   int16(14),
			Text:       "text",
			Time:       gotestparrot.Decode("0000-01-01T10:11:12Z", time.Time{}).(time.Time),
			Timestamp:  gotestparrot.Decode("2007-12-31T23:00:01Z", time.Time{}).(time.Time),
			TinyInt:    int8(-3),
			UBigInt:    uint64(0xc350),
			UInteger:   uint32(0x640),
			UMediumInt: uint32(0x96),
			USmallInt:  uint16(0xe),
			UTinyInt:   uint8(0x3),
			VarBinary:  []uint8{uint8(0x76), uint8(0x61), uint8(0x72), uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79)},
			VarChar:    "varchar",
			Year:       int16(2004),
		}},
	}})
	gotestparrot.R.Load("TestAllTypesViewSelect", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT all_types_view.boolean AS "all_types_view.boolean",
     all_types_view.boolean_ptr AS "all_types_view.boolean_ptr",
     all_types_view.tiny_int AS "all_types_view.tiny_int",
     all_types_view.u_tiny_int AS "all_types_view.u_tiny_int",
     all_types_view.small_int AS "all_types_view.small_int",
     all_types_view.u_small_int AS "all_types_view.u_small_int",
     all_types_view.medium_int AS "all_types_view.medium_int",
     all_types_view.u_medium_int AS "all_types_view.u_medium_int",
     all_types_view.` + "`" + `integer` + "`" + ` AS "all_types_view.integer",
     all_types_view.u_integer AS "all_types_view.u_integer",
     all_types_view.big_int AS "all_types_view.big_int",
     all_types_view.u_big_int AS "all_types_view.u_big_int",
     all_types_view.tiny_int_ptr AS "all_types_view.tiny_int_ptr",
     all_types_view.u_tiny_int_ptr AS "all_types_view.u_tiny_int_ptr",
     all_types_view.small_int_ptr AS "all_types_view.small_int_ptr",
     all_types_view.u_small_int_ptr AS "all_types_view.u_small_int_ptr",
     all_types_view.medium_int_ptr AS "all_types_view.medium_int_ptr",
     all_types_view.u_medium_int_ptr AS "all_types_view.u_medium_int_ptr",
     all_types_view.integer_ptr AS "all_types_view.integer_ptr",
     all_types_view.u_integer_ptr AS "all_types_view.u_integer_ptr",
     all_types_view.big_int_ptr AS "all_types_view.big_int_ptr",
     all_types_view.u_big_int_ptr AS "all_types_view.u_big_int_ptr",
     all_types_view.` + "`" + `decimal` + "`" + ` AS "all_types_view.decimal",
     all_types_view.decimal_ptr AS "all_types_view.decimal_ptr",
     all_types_view.` + "`" + `numeric` + "`" + ` AS "all_types_view.numeric",
     all_types_view.numeric_ptr AS "all_types_view.numeric_ptr",
     all_types_view.` + "`" + `float` + "`" + ` AS "all_types_view.float",
     all_types_view.float_ptr AS "all_types_view.float_ptr",
     all_types_view.` + "`" + `double` + "`" + ` AS "all_types_view.double",
     all_types_view.double_ptr AS "all_types_view.double_ptr",
     all_types_view.` + "`" + `real` + "`" + ` AS "all_types_view.real",
     all_types_view.real_ptr AS "all_types_view.real_ptr",
     all_types_view.bit AS "all_types_view.bit",
     all_types_view.bit_ptr AS "all_types_view.bit_ptr",
     all_types_view.time AS "all_types_view.time",
     all_types_view.time_ptr AS "all_types_view.time_ptr",
     all_types_view.date AS "all_types_view.date",
     all_types_view.date_ptr AS "all_types_view.date_ptr",
     all_types_view.date_time AS "all_types_view.date_time",
     all_types_view.date_time_ptr AS "all_types_view.date_time_ptr",
     all_types_view.timestamp AS "all_types_view.timestamp",
     all_types_view.timestamp_ptr AS "all_types_view.timestamp_ptr",
     all_types_view.year AS "all_types_view.year",
     all_types_view.year_ptr AS "all_types_view.year_ptr",
     all_types_view.` + "`" + `char` + "`" + ` AS "all_types_view.char",
     all_types_view.char_ptr AS "all_types_view.char_ptr",
     all_types_view.var_char AS "all_types_view.var_char",
     all_types_view.var_char_ptr AS "all_types_view.var_char_ptr",
     all_types_view.` + "`" + `binary` + "`" + ` AS "all_types_view.binary",
     all_types_view.binary_ptr AS "all_types_view.binary_ptr",
     all_types_view.var_binary AS "all_types_view.var_binary",
     all_types_view.var_binary_ptr AS "all_types_view.var_binary_ptr",
     all_types_view.` + "`" + `blob` + "`" + ` AS "all_types_view.blob",
     all_types_view.blob_ptr AS "all_types_view.blob_ptr",
     all_types_view.text AS "all_types_view.text",
     all_types_view.text_ptr AS "all_types_view.text_ptr",
     all_types_view.enum AS "all_types_view.enum",
     all_types_view.enum_ptr AS "all_types_view.enum_ptr",
     all_types_view.` + "`" + `set` + "`" + ` AS "all_types_view.set",
     all_types_view.set_ptr AS "all_types_view.set_ptr",
     all_types_view.json AS "all_types_view.json",
     all_types_view.json_ptr AS "all_types_view.json_ptr"
FROM test_sample.all_types_view;
`,
	}, {
		Key:   1,
		Value: []interface{}{},
	}, {
		Key: 2,
		Value: []AllTypesView{{
			BigInt:        int64(5000),
			BigIntPtr:     gotestparrot.Ptr(int64(50000)).(*int64),
			Binary:        []uint8{uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)},
			BinaryPtr:     gotestparrot.Ptr([]uint8{uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}).(*[]uint8),
			Bit:           "\x00\x03",
			BitPtr:        gotestparrot.Ptr("\x00\x03").(*string),
			Blob:          []uint8{uint8(0x62), uint8(0x6c), uint8(0x6f), uint8(0x62)},
			BlobPtr:       gotestparrot.Ptr([]uint8{uint8(0x62), uint8(0x6c), uint8(0x6f), uint8(0x62)}).(*[]uint8),
			BooleanPtr:    gotestparrot.Ptr(true).(*bool),
			Char:          "char",
			CharPtr:       gotestparrot.Ptr("char").(*string),
			Date:          gotestparrot.Decode("2008-07-04T00:00:00Z", time.Time{}).(time.Time),
			DatePtr:       gotestparrot.Decode("2008-07-04T00:00:00Z", &time.Time{}).(*time.Time),
			DateTime:      gotestparrot.Decode("2011-12-18T13:17:17Z", time.Time{}).(time.Time),
			DateTimePtr:   gotestparrot.Decode("2011-12-18T13:17:17Z", &time.Time{}).(*time.Time),
			Decimal:       1.11,
			DecimalPtr:    gotestparrot.Ptr(1.11).(*float64),
			Double:        4.44,
			DoublePtr:     gotestparrot.Ptr(4.44).(*float64),
			Enum:          model.AllTypesEnum("value1"),
			EnumPtr:       gotestparrot.Ptr(model.AllTypesEnumPtr("value1")).(*model.AllTypesEnumPtr),
			Float:         3.33,
			FloatPtr:      gotestparrot.Ptr(3.33).(*float64),
			Integer:       int32(-1600),
			IntegerPtr:    gotestparrot.Ptr(int32(-1600)).(*int32),
			JSON:          gotestparrot.Decode("{\"key1\": \"value1\", \"key2\": \"value2\"}", qrm.JSON{}).(qrm.JSON),
			JSONPtr:       gotestparrot.Decode("{\"key1\": \"value1\", \"key2\": \"value2\"}", &qrm.JSON{}).(*qrm.JSON),
			MediumInt:     int32(-150),
			MediumIntPtr:  gotestparrot.Ptr(int32(-150)).(*int32),
			Numeric:       2.22,
			NumericPtr:    gotestparrot.Ptr(2.22).(*float64),
			Real:          5.55,
			RealPtr:       gotestparrot.Ptr(5.55).(*float64),
			Set:           "s1",
			SetPtr:        gotestparrot.Ptr("s2").(*string),
			SmallInt:      int16(14),
			SmallIntPtr:   gotestparrot.Ptr(int16(14)).(*int16),
			Text:          "text",
			TextPtr:       gotestparrot.Ptr("text").(*string),
			Time:          gotestparrot.Decode("0000-01-01T10:11:12Z", time.Time{}).(time.Time),
			TimePtr:       gotestparrot.Decode("0000-01-01T10:11:12Z", &time.Time{}).(*time.Time),
			Timestamp:     gotestparrot.Decode("2007-12-31T23:00:01Z", time.Time{}).(time.Time),
			TimestampPtr:  gotestparrot.Decode("2007-12-31T23:00:01Z", &time.Time{}).(*time.Time),
			TinyInt:       int8(-3),
			TinyIntPtr:    gotestparrot.Ptr(int8(-3)).(*int8),
			UBigInt:       uint64(0xc350),
			UBigIntPtr:    gotestparrot.Ptr(uint64(0xc350)).(*uint64),
			UInteger:      uint32(0x640),
			UIntegerPtr:   gotestparrot.Ptr(uint32(0x640)).(*uint32),
			UMediumInt:    uint32(0x96),
			UMediumIntPtr: gotestparrot.Ptr(uint32(0x96)).(*uint32),
			USmallInt:     uint16(0xe),
			USmallIntPtr:  gotestparrot.Ptr(uint16(0xe)).(*uint16),
			UTinyInt:      uint8(0x3),
			UTinyIntPtr:   gotestparrot.Ptr(uint8(0x3)).(*uint8),
			VarBinary:     []uint8{uint8(0x76), uint8(0x61), uint8(0x72), uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79)},
			VarBinaryPtr:  gotestparrot.Ptr([]uint8{uint8(0x76), uint8(0x61), uint8(0x72), uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79)}).(*[]uint8),
			VarChar:       "varchar",
			VarCharPtr:    gotestparrot.Ptr("varchar").(*string),
			Year:          int16(2004),
			YearPtr:       gotestparrot.Ptr(int16(2004)).(*int16),
		}, {
			BigInt:     int64(5000),
			Binary:     []uint8{uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)},
			Bit:        "\x00\x03",
			Blob:       []uint8{uint8(0x62), uint8(0x6c), uint8(0x6f), uint8(0x62)},
			Char:       "char",
			Date:       gotestparrot.Decode("2008-07-04T00:00:00Z", time.Time{}).(time.Time),
			DateTime:   gotestparrot.Decode("2011-12-18T13:17:17Z", time.Time{}).(time.Time),
			Decimal:    1.11,
			Double:     4.44,
			Enum:       model.AllTypesEnum("value1"),
			Float:      3.33,
			Integer:    int32(-1600),
			JSON:       gotestparrot.Decode("{\"key1\": \"value1\", \"key2\": \"value2\"}", qrm.JSON{}).(qrm.JSON),
			MediumInt:  int32(-150),
			Numeric:    2.22,
			Real:       5.55,
			Set:        "s1",
			SmallInt:   int16(14),
			Text:       "text",
			Time:       gotestparrot.Decode("0000-01-01T10:11:12Z", time.Time{}).(time.Time),
			Timestamp:  gotestparrot.Decode("2007-12-31T23:00:01Z", time.Time{}).(time.Time),
			TinyInt:    int8(-3),
			UBigInt:    uint64(0xc350),
			UInteger:   uint32(0x640),
			UMediumInt: uint32(0x96),
			USmallInt:  uint16(0xe),
			UTinyInt:   uint8(0x3),
			VarBinary:  []uint8{uint8(0x76), uint8(0x61), uint8(0x72), uint8(0x62), uint8(0x69), uint8(0x6e), uint8(0x61), uint8(0x72), uint8(0x79)},
			VarChar:    "varchar",
			Year:       int16(2004),
		}},
	}})
	gotestparrot.R.Load("TestBoolOperators", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT (all_types.boolean = all_types.boolean_ptr) AS "EQ1",
     (all_types.boolean = ?) AS "EQ2",
     (all_types.boolean != all_types.boolean_ptr) AS "NEq1",
     (all_types.boolean != ?) AS "NEq2",
     (NOT(all_types.boolean <=> all_types.boolean_ptr)) AS "distinct1",
     (NOT(all_types.boolean <=> ?)) AS "distinct2",
     (all_types.boolean <=> all_types.boolean_ptr) AS "not_distinct_1",
     (all_types.boolean <=> ?) AS "NOTDISTINCT2",
     all_types.boolean IS TRUE AS "ISTRUE",
     all_types.boolean IS NOT TRUE AS "isnottrue",
     all_types.boolean IS FALSE AS "is_False",
     all_types.boolean IS NOT FALSE AS "is not false",
     all_types.boolean IS UNKNOWN AS "is unknown",
     all_types.boolean IS NOT UNKNOWN AS "is_not_unknown",
     ((all_types.boolean AND all_types.boolean) = (all_types.boolean AND all_types.boolean)) AS "complex1",
     ((all_types.boolean OR all_types.boolean) = (all_types.boolean AND all_types.boolean)) AS "complex2"
FROM test_sample.all_types;
`,
	}, {
		Key:   1,
		Value: []interface{}{true, false, true, true},
	}, {
		Key: 2,
		Value: []struct {
			Eq1          *bool
			Eq2          *bool
			NEq1         *bool
			NEq2         *bool
			Distinct1    *bool
			Distinct2    *bool
			NotDistinct1 *bool
			NotDistinct2 *bool
			IsTrue       *bool
			IsNotTrue    *bool
			IsFalse      *bool
			IsNotFalse   *bool
			IsUnknown    *bool
			IsNotUnknown *bool
			Complex1     *bool
			Complex2     *bool
		}{{
			Complex1:     gotestparrot.Ptr(true).(*bool),
			Complex2:     gotestparrot.Ptr(true).(*bool),
			Distinct1:    gotestparrot.Ptr(true).(*bool),
			Distinct2:    gotestparrot.Ptr(true).(*bool),
			Eq1:          gotestparrot.Ptr(false).(*bool),
			Eq2:          gotestparrot.Ptr(false).(*bool),
			IsFalse:      gotestparrot.Ptr(true).(*bool),
			IsNotFalse:   gotestparrot.Ptr(false).(*bool),
			IsNotTrue:    gotestparrot.Ptr(true).(*bool),
			IsNotUnknown: gotestparrot.Ptr(true).(*bool),
			IsTrue:       gotestparrot.Ptr(false).(*bool),
			IsUnknown:    gotestparrot.Ptr(false).(*bool),
			NEq1:         gotestparrot.Ptr(true).(*bool),
			NEq2:         gotestparrot.Ptr(false).(*bool),
			NotDistinct1: gotestparrot.Ptr(false).(*bool),
			NotDistinct2: gotestparrot.Ptr(false).(*bool),
		}, {
			Complex1:     gotestparrot.Ptr(true).(*bool),
			Complex2:     gotestparrot.Ptr(true).(*bool),
			Distinct1:    gotestparrot.Ptr(true).(*bool),
			Distinct2:    gotestparrot.Ptr(true).(*bool),
			Eq2:          gotestparrot.Ptr(false).(*bool),
			IsFalse:      gotestparrot.Ptr(true).(*bool),
			IsNotFalse:   gotestparrot.Ptr(false).(*bool),
			IsNotTrue:    gotestparrot.Ptr(true).(*bool),
			IsNotUnknown: gotestparrot.Ptr(true).(*bool),
			IsTrue:       gotestparrot.Ptr(false).(*bool),
			IsUnknown:    gotestparrot.Ptr(false).(*bool),
			NEq2:         gotestparrot.Ptr(false).(*bool),
			NotDistinct1: gotestparrot.Ptr(false).(*bool),
			NotDistinct2: gotestparrot.Ptr(false).(*bool),
		}},
	}})
	gotestparrot.R.Load("TestDateExpressions", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT CAST(? AS DATE),
     all_types.date = all_types.date,
     all_types.date = CAST(? AS DATE),
     all_types.date_ptr != all_types.date,
     all_types.date_ptr != CAST(? AS DATE),
     NOT(all_types.date <=> all_types.date),
     NOT(all_types.date <=> CAST(? AS DATE)),
     all_types.date <=> all_types.date,
     all_types.date <=> CAST(? AS DATE),
     all_types.date < all_types.date,
     all_types.date < CAST(? AS DATE),
     all_types.date <= all_types.date,
     all_types.date <= CAST(? AS DATE),
     all_types.date > all_types.date,
     all_types.date > CAST(? AS DATE),
     all_types.date >= all_types.date,
     all_types.date >= CAST(? AS DATE),
     all_types.date + INTERVAL ? MINUTE_MICROSECOND,
     all_types.date + INTERVAL all_types.big_int MINUTE,
     all_types.date + INTERVAL 15 HOUR,
     all_types.date - INTERVAL 20 MINUTE,
     all_types.date - INTERVAL all_types.small_int MINUTE,
     all_types.date - INTERVAL 3 MINUTE,
     CURRENT_DATE
FROM test_sample.all_types;
`,
	}, {
		Key:   1,
		Value: []interface{}{"2009-11-17", "2019-06-06", "2019-01-06", "2019-02-06", "2019-03-06", "2019-04-06", "2019-05-05", "2019-01-04", "2019-02-03", "10:20.000100"},
	}})
	gotestparrot.R.Load("TestDateTimeExpressions", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT all_types.date_time = all_types.date_time,
     all_types.date_time = CAST(? AS DATETIME),
     all_types.date_time_ptr != all_types.date_time,
     all_types.date_time_ptr != CAST(? AS DATETIME),
     NOT(all_types.date_time <=> all_types.date_time),
     NOT(all_types.date_time <=> CAST(? AS DATETIME)),
     all_types.date_time <=> all_types.date_time,
     all_types.date_time <=> CAST(? AS DATETIME),
     all_types.date_time < all_types.date_time,
     all_types.date_time < CAST(? AS DATETIME),
     all_types.date_time <= all_types.date_time,
     all_types.date_time <= CAST(? AS DATETIME),
     all_types.date_time > all_types.date_time,
     all_types.date_time > CAST(? AS DATETIME),
     all_types.date_time >= all_types.date_time,
     all_types.date_time >= CAST(? AS DATETIME),
     all_types.date_time + INTERVAL ? HOUR_MICROSECOND,
     all_types.date_time + INTERVAL all_types.big_int HOUR,
     all_types.date_time + INTERVAL 2 HOUR,
     all_types.date_time - INTERVAL ? HOUR_MICROSECOND,
     all_types.date_time - INTERVAL all_types.integer_ptr HOUR,
     all_types.date_time - INTERVAL 3 HOUR,
     NOW(),
     NOW(1)
FROM test_sample.all_types;
`,
	}, {
		Key:   1,
		Value: []interface{}{"2019-06-06 10:02:46", "2019-06-06 10:02:46.100", "2019-06-06 10:02:46", "2019-06-06 10:02:46", "2019-06-06 10:02:46", "2019-06-06 10:02:46", "2019-06-06 10:02:46", "2019-06-06 10:02:46", "05:10:20.000100", "05:10:20.000100"},
	}})
	gotestparrot.R.Load("TestExpressionOperators", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT all_types.` + "`" + `integer` + "`" + ` IS NULL AS "result.is_null",
     all_types.date_ptr IS NOT NULL AS "result.is_not_null",
     (all_types.small_int_ptr IN (?, ?)) AS "result.in",
     (all_types.small_int_ptr IN ((
          SELECT all_types.` + "`" + `integer` + "`" + ` AS "all_types.integer"
          FROM test_sample.all_types
     ))) AS "result.in_select",
     (all_types.small_int_ptr NOT IN (?, ?, NULL)) AS "result.not_in",
     (all_types.small_int_ptr NOT IN ((
          SELECT all_types.` + "`" + `integer` + "`" + ` AS "all_types.integer"
          FROM test_sample.all_types
     ))) AS "result.not_in_select",
     DATABASE()
FROM test_sample.all_types
LIMIT ?;
`,
	}, {
		Key:   1,
		Value: []interface{}{int64(11), int64(22), int64(11), int64(22), int64(2)},
	}, {
		Key: 2,
		Value: []struct {
			common.ExpressionTestResult `alias:"result.*"`
		}{{ExpressionTestResult: common.ExpressionTestResult{
			In:          gotestparrot.Ptr(false).(*bool),
			InSelect:    gotestparrot.Ptr(false).(*bool),
			IsNotNull:   gotestparrot.Ptr(true).(*bool),
			IsNull:      gotestparrot.Ptr(false).(*bool),
			NotInSelect: gotestparrot.Ptr(true).(*bool),
		}}, {ExpressionTestResult: common.ExpressionTestResult{
			IsNotNull: gotestparrot.Ptr(false).(*bool),
			IsNull:    gotestparrot.Ptr(false).(*bool),
		}}},
	}})
	gotestparrot.R.Load("TestFloatOperators", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT (all_types.` + "`" + `numeric` + "`" + ` = all_types.` + "`" + `numeric` + "`" + `) AS "eq1",
     (all_types.` + "`" + `decimal` + "`" + ` = ?) AS "eq2",
     (all_types.` + "`" + `real` + "`" + ` = ?) AS "eq3",
     (NOT(all_types.` + "`" + `numeric` + "`" + ` <=> all_types.` + "`" + `numeric` + "`" + `)) AS "distinct1",
     (NOT(all_types.` + "`" + `decimal` + "`" + ` <=> ?)) AS "distinct2",
     (NOT(all_types.` + "`" + `real` + "`" + ` <=> ?)) AS "distinct3",
     (all_types.` + "`" + `numeric` + "`" + ` <=> all_types.` + "`" + `numeric` + "`" + `) AS "not_distinct1",
     (all_types.` + "`" + `decimal` + "`" + ` <=> ?) AS "not_distinct2",
     (all_types.` + "`" + `real` + "`" + ` <=> ?) AS "not_distinct3",
     (all_types.` + "`" + `numeric` + "`" + ` < ?) AS "lt1",
     (all_types.` + "`" + `numeric` + "`" + ` < ?) AS "lt2",
     (all_types.` + "`" + `numeric` + "`" + ` > ?) AS "gt1",
     (all_types.` + "`" + `numeric` + "`" + ` > ?) AS "gt2",
     TRUNCATE((all_types.` + "`" + `decimal` + "`" + ` + all_types.` + "`" + `decimal` + "`" + `), ?) AS "add1",
     TRUNCATE((all_types.` + "`" + `decimal` + "`" + ` + ?), ?) AS "add2",
     TRUNCATE((all_types.` + "`" + `decimal` + "`" + ` - all_types.decimal_ptr), ?) AS "sub1",
     TRUNCATE((all_types.` + "`" + `decimal` + "`" + ` - ?), ?) AS "sub2",
     TRUNCATE((all_types.` + "`" + `decimal` + "`" + ` * all_types.decimal_ptr), ?) AS "mul1",
     TRUNCATE((all_types.` + "`" + `decimal` + "`" + ` * ?), ?) AS "mul2",
     TRUNCATE((all_types.` + "`" + `decimal` + "`" + ` / all_types.decimal_ptr), ?) AS "div1",
     TRUNCATE((all_types.` + "`" + `decimal` + "`" + ` / ?), ?) AS "div2",
     TRUNCATE((all_types.` + "`" + `decimal` + "`" + ` % all_types.decimal_ptr), ?) AS "mod1",
     TRUNCATE((all_types.` + "`" + `decimal` + "`" + ` % ?), ?) AS "mod2",
     TRUNCATE(POW(all_types.` + "`" + `decimal` + "`" + `, all_types.decimal_ptr), ?) AS "pow1",
     TRUNCATE(POW(all_types.` + "`" + `decimal` + "`" + `, ?), ?) AS "pow2",
     TRUNCATE(ABS(all_types.` + "`" + `decimal` + "`" + `), ?) AS "abs",
     TRUNCATE(POWER(all_types.` + "`" + `decimal` + "`" + `, ?), ?) AS "power",
     TRUNCATE(SQRT(all_types.` + "`" + `decimal` + "`" + `), ?) AS "sqrt",
     TRUNCATE(POWER(all_types.` + "`" + `decimal` + "`" + `, (? / ?)), ?) AS "cbrt",
     CEIL(all_types.` + "`" + `real` + "`" + `) AS "ceil",
     FLOOR(all_types.` + "`" + `real` + "`" + `) AS "floor",
     ROUND(all_types.` + "`" + `decimal` + "`" + `) AS "round1",
     ROUND(all_types.` + "`" + `decimal` + "`" + `, ?) AS "round2",
     SIGN(all_types.` + "`" + `real` + "`" + `) AS "sign",
     TRUNCATE(all_types.` + "`" + `decimal` + "`" + `, ?) AS "trunc"
FROM test_sample.all_types
LIMIT ?;
`,
	}, {
		Key:   1,
		Value: []interface{}{12.22, 12.12, 12.0, 12.12, 12.0, 12.12, 124.0, 34.56, 124.0, 34.56, int64(2), 11.22, int64(2), int64(2), 11.22, int64(2), int64(2), 11.22, int64(2), int64(2), 11.22, int64(2), int64(2), 11.22, int64(2), int64(2), 2.1, int64(2), int64(2), 2.1, int64(2), int64(2), 1.0, 3.0, int64(2), int64(2), int64(1), int64(2)},
	}, {
		Key: 2,
		Value: []struct {
			common.FloatExpressionTestResult `alias:"."`
		}{{FloatExpressionTestResult: common.FloatExpressionTestResult{
			Abs:          gotestparrot.Ptr(1.11).(*float64),
			Add1:         gotestparrot.Ptr(2.22).(*float64),
			Add2:         gotestparrot.Ptr(12.33).(*float64),
			Cbrt:         gotestparrot.Ptr(1.03).(*float64),
			Ceil:         gotestparrot.Ptr(6.0).(*float64),
			Distinct1:    gotestparrot.Ptr(false).(*bool),
			Distinct2:    gotestparrot.Ptr(true).(*bool),
			Distinct3:    gotestparrot.Ptr(true).(*bool),
			Div1:         gotestparrot.Ptr(1.0).(*float64),
			Div2:         gotestparrot.Ptr(0.09).(*float64),
			Eq1:          gotestparrot.Ptr(true).(*bool),
			Eq2:          gotestparrot.Ptr(false).(*bool),
			Eq3:          gotestparrot.Ptr(false).(*bool),
			Floor:        gotestparrot.Ptr(5.0).(*float64),
			Gt1:          gotestparrot.Ptr(false).(*bool),
			Gt2:          gotestparrot.Ptr(false).(*bool),
			Lt1:          gotestparrot.Ptr(true).(*bool),
			Lt2:          gotestparrot.Ptr(true).(*bool),
			Mod1:         gotestparrot.Ptr(0.0).(*float64),
			Mod2:         gotestparrot.Ptr(1.11).(*float64),
			Mul1:         gotestparrot.Ptr(1.23).(*float64),
			Mul2:         gotestparrot.Ptr(12.45).(*float64),
			NotDistinct1: gotestparrot.Ptr(true).(*bool),
			NotDistinct2: gotestparrot.Ptr(false).(*bool),
			NotDistinct3: gotestparrot.Ptr(false).(*bool),
			Pow1:         gotestparrot.Ptr(1.12).(*float64),
			Pow2:         gotestparrot.Ptr(1.24).(*float64),
			Power:        gotestparrot.Ptr(1.24).(*float64),
			Round1:       gotestparrot.Ptr(1.0).(*float64),
			Round2:       gotestparrot.Ptr(1.11).(*float64),
			Sign:         gotestparrot.Ptr(1.0).(*float64),
			Sqrt:         gotestparrot.Ptr(1.05).(*float64),
			Sub1:         gotestparrot.Ptr(0.0).(*float64),
			Sub2:         gotestparrot.Ptr(-10.11).(*float64),
			Trunc:        gotestparrot.Ptr(1.1).(*float64),
		}}, {FloatExpressionTestResult: common.FloatExpressionTestResult{
			Abs:          gotestparrot.Ptr(1.11).(*float64),
			Add1:         gotestparrot.Ptr(2.22).(*float64),
			Add2:         gotestparrot.Ptr(12.33).(*float64),
			Cbrt:         gotestparrot.Ptr(1.03).(*float64),
			Ceil:         gotestparrot.Ptr(6.0).(*float64),
			Distinct1:    gotestparrot.Ptr(false).(*bool),
			Distinct2:    gotestparrot.Ptr(true).(*bool),
			Distinct3:    gotestparrot.Ptr(true).(*bool),
			Div2:         gotestparrot.Ptr(0.09).(*float64),
			Eq1:          gotestparrot.Ptr(true).(*bool),
			Eq2:          gotestparrot.Ptr(false).(*bool),
			Eq3:          gotestparrot.Ptr(false).(*bool),
			Floor:        gotestparrot.Ptr(5.0).(*float64),
			Gt1:          gotestparrot.Ptr(false).(*bool),
			Gt2:          gotestparrot.Ptr(false).(*bool),
			Lt1:          gotestparrot.Ptr(true).(*bool),
			Lt2:          gotestparrot.Ptr(true).(*bool),
			Mod2:         gotestparrot.Ptr(1.11).(*float64),
			Mul2:         gotestparrot.Ptr(12.45).(*float64),
			NotDistinct1: gotestparrot.Ptr(true).(*bool),
			NotDistinct2: gotestparrot.Ptr(false).(*bool),
			NotDistinct3: gotestparrot.Ptr(false).(*bool),
			Pow2:         gotestparrot.Ptr(1.24).(*float64),
			Power:        gotestparrot.Ptr(1.24).(*float64),
			Round1:       gotestparrot.Ptr(1.0).(*float64),
			Round2:       gotestparrot.Ptr(1.11).(*float64),
			Sign:         gotestparrot.Ptr(1.0).(*float64),
			Sqrt:         gotestparrot.Ptr(1.05).(*float64),
			Sub2:         gotestparrot.Ptr(-10.11).(*float64),
			Trunc:        gotestparrot.Ptr(1.1).(*float64),
		}}},
	}})
	gotestparrot.R.Load("TestINTERVAL", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT (CAST(? AS DATE) + INTERVAL 1 MICROSECOND) = TIMESTAMP(?),
     CAST(? AS DATE) - INTERVAL 2 SECOND,
     CAST(? AS DATE) + INTERVAL 3 MINUTE,
     CAST(? AS DATE) - INTERVAL 4 HOUR,
     CAST(? AS DATE) + INTERVAL 5 DAY,
     CAST(? AS DATE) - INTERVAL 6 MONTH,
     CAST(? AS DATE) + INTERVAL 7 YEAR,
     CAST(? AS DATE) + INTERVAL -7 YEAR,
     CAST(? AS DATE) + INTERVAL ? SECOND_MICROSECOND,
     CAST(? AS DATE) - INTERVAL ? MINUTE_MICROSECOND,
     CAST(? AS DATE) - INTERVAL ? HOUR_MICROSECOND,
     CAST(? AS DATE) - INTERVAL ? DAY_MICROSECOND,
     CAST(? AS DATE) - INTERVAL ? MINUTE_SECOND,
     CAST(? AS DATE) - INTERVAL ? HOUR_SECOND,
     CAST(? AS DATE) - INTERVAL ? HOUR_MINUTE,
     CAST(? AS DATE) - INTERVAL ? DAY_SECOND,
     CAST(? AS DATE) - INTERVAL ? DAY_MINUTE,
     CAST(? AS DATE) - INTERVAL ? DAY_HOUR,
     CAST(? AS DATE) - INTERVAL ? YEAR_MONTH,
     CAST(? AS DATE) - INTERVAL all_types.integer_ptr MICROSECOND,
     CAST(? AS DATE) - INTERVAL all_types.integer_ptr SECOND,
     CAST(? AS DATE) - INTERVAL all_types.integer_ptr MINUTE,
     CAST(? AS DATE) - INTERVAL all_types.integer_ptr HOUR,
     CAST(? AS DATE) - INTERVAL all_types.integer_ptr DAY,
     CAST(? AS DATE) - INTERVAL all_types.integer_ptr WEEK,
     CAST(? AS DATE) - INTERVAL all_types.integer_ptr MONTH,
     CAST(? AS DATE) - INTERVAL all_types.integer_ptr QUARTER,
     CAST(? AS DATE) - INTERVAL all_types.integer_ptr YEAR,
     CAST(? AS DATE) - INTERVAL 3 MICROSECOND,
     CAST(? AS DATE) - INTERVAL -3 MICROSECOND,
     CAST(? AS DATE) - INTERVAL 3 SECOND,
     CAST(? AS DATE) - INTERVAL ? SECOND_MICROSECOND,
     CAST(? AS DATE) - INTERVAL ? MINUTE_MICROSECOND,
     CAST(? AS DATE) - INTERVAL ? HOUR_MICROSECOND,
     CAST(? AS DATE) - INTERVAL ? DAY_MICROSECOND,
     CAST(? AS DATE) - INTERVAL ? DAY_SECOND,
     CAST(? AS DATE) - INTERVAL ? DAY_MINUTE,
     CAST(? AS DATE) - INTERVAL ? DAY_HOUR,
     CAST(? AS DATE) - INTERVAL 2 DAY,
     CAST(? AS DATE) - INTERVAL 3 HOUR,
     CAST(? AS DATE) - INTERVAL ? HOUR_MICROSECOND
FROM test_sample.all_types;
`,
	}, {
		Key:   1,
		Value: []interface{}{"2000-02-10", "2000-02-10 00:00:00.000001", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "20.0000100", "2000-02-10", "02:20.0000100", "2000-02-10", "11:02:20.0000100", "2000-02-10", "100 11:02:20.0000100", "2000-02-10", "11:02", "2000-02-10", "11:02:20", "2000-02-10", "11:02", "2000-02-10", "11 02:03:04", "2000-02-10", "11 02:03", "2000-02-10", "11 2", "2000-02-10", "2000-2", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "2000-02-10", "03.000004", "2000-02-10", "03:04.000005", "2000-02-10", "03:04:05.000006", "2000-02-10", "2 03:04:05.000006", "2000-02-10", "2 03:04:05", "2000-02-10", "2 03:04", "2000-02-10", "2 03", "2000-02-10", "2000-02-10", "2000-02-10", "01:02:03.000345"},
	}})
	gotestparrot.R.Load("TestIntegerOperators", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT all_types.big_int AS "all_types.big_int",
     all_types.big_int_ptr AS "all_types.big_int_ptr",
     all_types.small_int AS "all_types.small_int",
     all_types.small_int_ptr AS "all_types.small_int_ptr",
     (all_types.big_int = all_types.big_int) AS "eq1",
     (all_types.big_int = ?) AS "eq2",
     (all_types.big_int != all_types.big_int_ptr) AS "neq1",
     (all_types.big_int != ?) AS "neq2",
     (NOT(all_types.big_int <=> all_types.big_int)) AS "distinct1",
     (NOT(all_types.big_int <=> ?)) AS "distinct2",
     (all_types.big_int <=> all_types.big_int) AS "not distinct1",
     (all_types.big_int <=> ?) AS "not distinct2",
     (all_types.big_int < all_types.big_int_ptr) AS "lt1",
     (all_types.big_int < ?) AS "lt2",
     (all_types.big_int <= all_types.big_int_ptr) AS "lte1",
     (all_types.big_int <= ?) AS "lte2",
     (all_types.big_int > all_types.big_int_ptr) AS "gt1",
     (all_types.big_int > ?) AS "gt2",
     (all_types.big_int >= all_types.big_int_ptr) AS "gte1",
     (all_types.big_int >= ?) AS "gte2",
     (all_types.big_int + all_types.big_int) AS "add1",
     (all_types.big_int + ?) AS "add2",
     (all_types.big_int - all_types.big_int) AS "sub1",
     (all_types.big_int - ?) AS "sub2",
     (all_types.big_int * all_types.big_int) AS "mul1",
     (all_types.big_int * ?) AS "mul2",
     (all_types.big_int DIV all_types.big_int) AS "div1",
     (all_types.big_int DIV ?) AS "div2",
     (all_types.big_int % all_types.big_int) AS "mod1",
     (all_types.big_int % ?) AS "mod2",
     POW(all_types.small_int, (all_types.small_int DIV ?)) AS "pow1",
     POW(all_types.small_int, ?) AS "pow2",
     (all_types.small_int & all_types.small_int) AS "bit_and1",
     (all_types.small_int & all_types.small_int) AS "bit_and2",
     (all_types.small_int | all_types.small_int) AS "bit or 1",
     (all_types.small_int | ?) AS "bit or 2",
     (all_types.small_int ^ all_types.small_int) AS "bit xor 1",
     (all_types.small_int ^ ?) AS "bit xor 2",
     (~ (? * all_types.small_int)) AS "bit_not_1",
     (~ (? * ?)) AS "bit_not_2",
     (all_types.small_int << (all_types.small_int DIV ?)) AS "bit shift left 1",
     (all_types.small_int << ?) AS "bit shift left 2",
     (all_types.small_int >> (all_types.small_int DIV ?)) AS "bit shift right 1",
     (all_types.small_int >> ?) AS "bit shift right 2",
     ABS(all_types.big_int) AS "abs",
     SQRT(ABS(all_types.big_int)) AS "sqrt",
     POWER(ABS(all_types.big_int), (? / ?)) AS "cbrt"
FROM test_sample.all_types
LIMIT ?;
`,
	}, {
		Key:   1,
		Value: []interface{}{int64(12), int64(12), int64(12), int64(12), int64(65), int64(65), int64(65), int64(65), int64(11), int64(11), int64(11), int64(11), int64(11), int64(3), int64(6), int64(22), int64(11), int64(-1), int64(-1), int64(11), int64(2), int64(4), int64(5), int64(1), 1.0, 3.0, int64(2)},
	}, {
		Key: 2,
		Value: []struct {
			common.AllTypesIntegerExpResult `alias:"."`
		}{{AllTypesIntegerExpResult: common.AllTypesIntegerExpResult{
			Add1:           gotestparrot.Ptr(int64(10000)).(*int64),
			Add2:           gotestparrot.Ptr(int64(5011)).(*int64),
			BitAnd1:        gotestparrot.Ptr(int64(14)).(*int64),
			BitAnd2:        gotestparrot.Ptr(int64(14)).(*int64),
			BitOr1:         gotestparrot.Ptr(int64(14)).(*int64),
			BitOr2:         gotestparrot.Ptr(int64(30)).(*int64),
			BitShiftLeft1:  gotestparrot.Ptr(int64(1792)).(*int64),
			BitShiftLeft2:  gotestparrot.Ptr(int64(224)).(*int64),
			BitShiftRight1: gotestparrot.Ptr(int64(3)).(*int64),
			BitShiftRight2: gotestparrot.Ptr(int64(7)).(*int64),
			BitXor1:        gotestparrot.Ptr(int64(0)).(*int64),
			BitXor2:        gotestparrot.Ptr(int64(5)).(*int64),
			Div1:           gotestparrot.Ptr(int64(1)).(*int64),
			Div2:           gotestparrot.Ptr(int64(454)).(*int64),
			EqualityExpResult: common.EqualityExpResult{
				Distinct1:    gotestparrot.Ptr(false).(*bool),
				Distinct2:    gotestparrot.Ptr(true).(*bool),
				Eq1:          gotestparrot.Ptr(true).(*bool),
				Eq2:          gotestparrot.Ptr(false).(*bool),
				Gt1:          gotestparrot.Ptr(false).(*bool),
				Gt2:          gotestparrot.Ptr(true).(*bool),
				Gte1:         gotestparrot.Ptr(false).(*bool),
				Gte2:         gotestparrot.Ptr(true).(*bool),
				Lt1:          gotestparrot.Ptr(true).(*bool),
				Lt2:          gotestparrot.Ptr(false).(*bool),
				Lte1:         gotestparrot.Ptr(true).(*bool),
				Lte2:         gotestparrot.Ptr(false).(*bool),
				NotDistinct1: gotestparrot.Ptr(true).(*bool),
				NotDistinct2: gotestparrot.Ptr(false).(*bool),
			},
			Mod1: gotestparrot.Ptr(int64(0)).(*int64),
			Mod2: gotestparrot.Ptr(int64(6)).(*int64),
			Mul1: gotestparrot.Ptr(int64(25000000)).(*int64),
			Mul2: gotestparrot.Ptr(int64(55000)).(*int64),
			Pow1: gotestparrot.Ptr(int64(38416)).(*int64),
			Pow2: gotestparrot.Ptr(int64(7529536)).(*int64),
			Sub1: gotestparrot.Ptr(int64(0)).(*int64),
			Sub2: gotestparrot.Ptr(int64(4989)).(*int64),
		}}, {AllTypesIntegerExpResult: common.AllTypesIntegerExpResult{
			Add1:           gotestparrot.Ptr(int64(10000)).(*int64),
			Add2:           gotestparrot.Ptr(int64(5011)).(*int64),
			BitAnd1:        gotestparrot.Ptr(int64(14)).(*int64),
			BitAnd2:        gotestparrot.Ptr(int64(14)).(*int64),
			BitOr1:         gotestparrot.Ptr(int64(14)).(*int64),
			BitOr2:         gotestparrot.Ptr(int64(30)).(*int64),
			BitShiftLeft1:  gotestparrot.Ptr(int64(1792)).(*int64),
			BitShiftLeft2:  gotestparrot.Ptr(int64(224)).(*int64),
			BitShiftRight1: gotestparrot.Ptr(int64(3)).(*int64),
			BitShiftRight2: gotestparrot.Ptr(int64(7)).(*int64),
			BitXor1:        gotestparrot.Ptr(int64(0)).(*int64),
			BitXor2:        gotestparrot.Ptr(int64(5)).(*int64),
			Div1:           gotestparrot.Ptr(int64(1)).(*int64),
			Div2:           gotestparrot.Ptr(int64(454)).(*int64),
			EqualityExpResult: common.EqualityExpResult{
				Distinct1:    gotestparrot.Ptr(false).(*bool),
				Distinct2:    gotestparrot.Ptr(true).(*bool),
				Eq1:          gotestparrot.Ptr(true).(*bool),
				Eq2:          gotestparrot.Ptr(false).(*bool),
				Gt2:          gotestparrot.Ptr(true).(*bool),
				Gte2:         gotestparrot.Ptr(true).(*bool),
				Lt2:          gotestparrot.Ptr(false).(*bool),
				Lte2:         gotestparrot.Ptr(false).(*bool),
				NotDistinct1: gotestparrot.Ptr(true).(*bool),
				NotDistinct2: gotestparrot.Ptr(false).(*bool),
			},
			Mod1: gotestparrot.Ptr(int64(0)).(*int64),
			Mod2: gotestparrot.Ptr(int64(6)).(*int64),
			Mul1: gotestparrot.Ptr(int64(25000000)).(*int64),
			Mul2: gotestparrot.Ptr(int64(55000)).(*int64),
			Pow1: gotestparrot.Ptr(int64(38416)).(*int64),
			Pow2: gotestparrot.Ptr(int64(7529536)).(*int64),
			Sub1: gotestparrot.Ptr(int64(0)).(*int64),
			Sub2: gotestparrot.Ptr(int64(4989)).(*int64),
		}}},
	}})
	gotestparrot.R.Load("TestReservedWord", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT user.` + "`" + `column` + "`" + ` AS "user.column",
     user.` + "`" + `use` + "`" + ` AS "user.use",
     user.ceil AS "user.ceil",
     user.commit AS "user.commit",
     user.` + "`" + `create` + "`" + ` AS "user.create",
     user.` + "`" + `default` + "`" + ` AS "user.default",
     user.` + "`" + `desc` + "`" + ` AS "user.desc",
     user.` + "`" + `empty` + "`" + ` AS "user.empty",
     user.` + "`" + `float` + "`" + ` AS "user.float",
     user.` + "`" + `join` + "`" + ` AS "user.join",
     user.` + "`" + `like` + "`" + ` AS "user.like",
     user.max AS "user.max",
     user.` + "`" + `rank` + "`" + ` AS "user.rank"
FROM test_sample.user;
`,
	}, {
		Key:   1,
		Value: []interface{}{},
	}, {
		Key: 2,
		Value: []model.User{{
			Ceil:    "CEIL",
			Column:  "Column",
			Commit:  "COMMIT",
			Create:  "CREATE",
			Default: "DEFAULT",
			Desc:    "DESC",
			Empty:   "EMPTY",
			Float:   "FLOAT",
			Join:    "JOIN",
			Like:    "LIKE",
			Max:     "MAX",
			Rank:    "RANK",
			Use:     "CHECK",
		}},
	}})
	gotestparrot.R.Load("TestStringOperators", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT all_types.text = all_types.` + "`" + `char` + "`" + `,
     all_types.text = ?,
     all_types.text != all_types.var_char_ptr,
     all_types.text != ?,
     all_types.text > all_types.text,
     all_types.text > ?,
     all_types.text >= all_types.text_ptr,
     all_types.text >= ?,
     all_types.text < all_types.` + "`" + `char` + "`" + `,
     all_types.text < ?,
     all_types.text <= all_types.var_char_ptr,
     all_types.text <= ?,
     CONCAT(all_types.text, ?),
     CONCAT(all_types.text, ?),
     all_types.text LIKE ?,
     all_types.text NOT LIKE ?,
     all_types.text REGEXP ?,
     all_types.text REGEXP ?,
     CAST(? AS BINARY) REGEXP BINARY ?,
     all_types.text NOT REGEXP ?,
     all_types.text NOT REGEXP ?,
     CAST(? AS BINARY) NOT REGEXP BINARY ?,
     BIT_LENGTH(all_types.text),
     CHAR_LENGTH(all_types.` + "`" + `char` + "`" + `),
     OCTET_LENGTH(all_types.text),
     LOWER(all_types.var_char_ptr),
     UPPER(all_types.` + "`" + `char` + "`" + `),
     LTRIM(all_types.var_char_ptr),
     RTRIM(all_types.var_char_ptr),
     CONCAT(?, ?, ?),
     CONCAT_WS(?, ?, ?),
     FORMAT(?, ?),
     LEFT(?, ?),
     RIGHT(?, ?),
     LENGTH(?),
     LPAD(?, ?, ?),
     RPAD(?, ?, ?),
     MD5(all_types.var_char_ptr),
     REPEAT(all_types.text, ?),
     REPLACE(all_types.` + "`" + `char` + "`" + `, ?, ?),
     REVERSE(all_types.var_char_ptr),
     SUBSTR(all_types.char_ptr, ?),
     SUBSTR(all_types.char_ptr, ?, ?)
FROM test_sample.all_types;
`,
	}, {
		Key:   1,
		Value: []interface{}{"Text", "Text", "Text", "Text", "Text", "Text", "text2", int64(11), "abc", "_b_", "aba", "aba", "ABA", "aba", "aba", "aba", "ABA", "aba", "string1", int64(1), 11.12, "string1", int64(1), 11.12, "Hello %s, %1$s", "World", "abcde", int64(2), "abcde", int64(2), "jose", "Hi", int64(5), "xy", "Hi", int64(5), "xy", int64(33), "BA", "AB", int64(3), int64(3), int64(2)},
	}})
	gotestparrot.R.Load("TestTimeExpressions", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT CAST(? AS TIME),
     all_types.time = all_types.time,
     all_types.time = CAST(? AS TIME),
     all_types.time = CAST(? AS TIME),
     all_types.time = CAST(? AS TIME),
     all_types.time_ptr != all_types.time,
     all_types.time_ptr != CAST(? AS TIME),
     NOT(all_types.time <=> all_types.time),
     NOT(all_types.time <=> CAST(? AS TIME)),
     all_types.time <=> all_types.time,
     all_types.time <=> CAST(? AS TIME),
     all_types.time < all_types.time,
     all_types.time < CAST(? AS TIME),
     all_types.time <= all_types.time,
     all_types.time <= CAST(? AS TIME),
     all_types.time > all_types.time,
     all_types.time > CAST(? AS TIME),
     all_types.time >= all_types.time,
     all_types.time >= CAST(? AS TIME),
     all_types.time + INTERVAL 10 MINUTE,
     all_types.time + INTERVAL all_types.` + "`" + `integer` + "`" + ` MINUTE,
     all_types.time + INTERVAL 3 HOUR,
     all_types.time - INTERVAL 20 MINUTE,
     all_types.time - INTERVAL all_types.small_int MINUTE,
     all_types.time - INTERVAL 3 MINUTE,
     (all_types.time + INTERVAL 20 MINUTE) - INTERVAL 11 HOUR,
     CURRENT_TIME,
     CURRENT_TIME(3)
FROM test_sample.all_types;
`,
	}, {
		Key:   1,
		Value: []interface{}{"20:34:58", "23:06:06", "22:06:06.011", "21:06:06.011111", "20:16:06", "19:26:06", "18:36:06", "17:46:06", "16:56:56", "15:16:46", "14:26:36"},
	}})
	gotestparrot.R.Load("TestTimeLiterals", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT CAST(? AS DATE) AS "date",
     CAST(? AS DATE) AS "dateT",
     CAST(? AS TIME) AS "time",
     CAST(? AS TIME) AS "timeT",
     CAST(? AS DATETIME) AS "datetime",
     TIMESTAMP(?) AS "timestamp",
     TIMESTAMP(?) AS "timestampT"
FROM test_sample.all_types
LIMIT ?;
`,
	}, {
		Key:   1,
		Value: []interface{}{"2009-11-17", gotestparrot.Decode("2009-11-17T20:34:58.351387237+01:00", time.Time{}).(time.Time), "20:34:58", gotestparrot.Decode("2009-11-17T20:34:58.351387237+01:00", time.Time{}).(time.Time), gotestparrot.Decode("2009-11-17T20:34:58.351387237+01:00", time.Time{}).(time.Time), "2019-08-06 10:10:30.123456", gotestparrot.Decode("2009-11-17T20:34:58.351387237+01:00", time.Time{}).(time.Time), int64(1)},
	}, {
		Key: 2,
		Value: struct {
			Date       time.Time
			DateT      time.Time
			Time       time.Time
			TimeT      time.Time
			DateTime   time.Time
			Timestamp  time.Time
			TimestampT time.Time
		}{
			Date:       gotestparrot.Decode("2009-11-17T00:00:00Z", time.Time{}).(time.Time),
			DateT:      gotestparrot.Decode("2009-11-17T00:00:00Z", time.Time{}).(time.Time),
			DateTime:   gotestparrot.Decode("2009-11-17T19:34:58Z", time.Time{}).(time.Time),
			Time:       gotestparrot.Decode("0000-01-01T20:34:58Z", time.Time{}).(time.Time),
			TimeT:      gotestparrot.Decode("0000-01-01T19:34:58Z", time.Time{}).(time.Time),
			Timestamp:  gotestparrot.Decode("2019-08-06T10:10:30Z", time.Time{}).(time.Time),
			TimestampT: gotestparrot.Decode("2009-11-17T19:34:58Z", time.Time{}).(time.Time),
		},
	}})
	gotestparrot.R.Load("TestTimestampExpressions", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT all_types.timestamp = all_types.timestamp,
     all_types.timestamp = TIMESTAMP(?),
     all_types.timestamp_ptr != all_types.timestamp,
     all_types.timestamp_ptr != TIMESTAMP(?),
     NOT(all_types.timestamp <=> all_types.timestamp),
     NOT(all_types.timestamp <=> TIMESTAMP(?)),
     all_types.timestamp <=> all_types.timestamp,
     all_types.timestamp <=> TIMESTAMP(?),
     all_types.timestamp < all_types.timestamp,
     all_types.timestamp < TIMESTAMP(?),
     all_types.timestamp <= all_types.timestamp,
     all_types.timestamp <= TIMESTAMP(?),
     all_types.timestamp > all_types.timestamp,
     all_types.timestamp > TIMESTAMP(?),
     all_types.timestamp >= all_types.timestamp,
     all_types.timestamp >= TIMESTAMP(?),
     all_types.timestamp + INTERVAL ? HOUR_MICROSECOND,
     all_types.timestamp + INTERVAL all_types.big_int HOUR,
     all_types.timestamp + INTERVAL 2 HOUR,
     all_types.timestamp - INTERVAL ? HOUR_MICROSECOND,
     all_types.timestamp - INTERVAL all_types.integer_ptr HOUR,
     all_types.timestamp - INTERVAL 3 HOUR,
     CURRENT_TIMESTAMP,
     CURRENT_TIMESTAMP(2)
FROM test_sample.all_types;
`,
	}, {
		Key:   1,
		Value: []interface{}{"2019-06-06 10:02:46", "2019-06-06 10:02:46.100", "2019-06-06 10:02:46", "2019-06-06 10:02:46", "2019-06-06 10:02:46", "2019-06-06 10:02:46", "2019-06-06 10:02:46", "2019-06-06 10:02:46", "05:10:20.000100", "05:10:20.000100"},
	}})
	gotestparrot.R.Load("TestUUID", []gotestparrot.Recording{{
		Key: 0,
		Value: `
SELECT ? AS "uuid",
     ? AS "ptr_uuid",
     unhex(replace('dc8daae3-b83b-11e9-8eb4-98ded00c39c6','-','')) AS "bin_uuid"
FROM test_sample.all_types
LIMIT ?;
`,
	}, {
		Key:   1,
		Value: []interface{}{"dc8daae3-b83b-11e9-8eb4-98ded00c39c6", "dc8daae3-b83b-11e9-8eb4-98ded00c39c6", int64(1)},
	}, {
		Key: 2,
		Value: struct {
			UUID    uuid.UUID
			PtrUUID *uuid.UUID
			BinUUID uuid.UUID
		}{
			BinUUID: gotestparrot.Decode("dc8daae3-b83b-11e9-8eb4-98ded00c39c6", uuid.UUID{}).(uuid.UUID),
			PtrUUID: gotestparrot.Decode("dc8daae3-b83b-11e9-8eb4-98ded00c39c6", &uuid.UUID{}).(*uuid.UUID),
			UUID:    gotestparrot.Decode("dc8daae3-b83b-11e9-8eb4-98ded00c39c6", uuid.UUID{}).(uuid.UUID),
		},
	}})
}
